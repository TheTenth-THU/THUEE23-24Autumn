\documentclass[10pt, a4paper, oneside, fontset=none]{ctexart}
%调用宏包
\usepackage{amsmath, amsthm, amssymb, graphicx, wrapfig, mathrsfs, upgreek}
\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]{hyperref}
\usepackage{color, framed, geometry, tcolorbox, multirow, booktabs}
\tcbuselibrary{breakable}%box跨页
\tcbuselibrary{skins}%box跨页不留边
%\usepackage{CJKpunct}
\usepackage{marginnote}
\usepackage{makecell, booktabs, longtable}
\usepackage[font=sf, labelfont+=bf]{caption}
\usepackage[font={small, sf}]{subfig}
\usepackage{adjustbox}
\usepackage{multicol}
\usepackage{arydshln, nicematrix}%矩阵
\usepackage{extarrows}
\usepackage[american, cuteinductors, ]{circuitikz}
\usepackage{xpatch}
\usepackage{rotating}%旋转
\usepackage{physics}
\usepackage{siunitx}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{dashrule}
\usepackage{tablefootnote}%表格脚注
\usepackage[text=\includegraphics{C:/Users/16870/.vscode/LaTeX_Application/tex/THUEE23-23Autumn/图标简稿.png},angle=0]{draftwatermark}%水印
%\usepackage{tikz}
%基本字体设置
\usepackage[math-style=ISO, bold-style=ISO]{unicode-math}
\setmainfont{KpRoman}
%\setmainfont{EB Garamond}
%\setmathfont{Garamond-Math.otf}[StylisticSet={7,9}]
\setmonofont{Iosevka}
\setmathfont{KpMath-Regular.otf}%NewCMMath-Regular
%\setmathfont[range=bb]{TeXGyrePagellaMath-Regular}
%\setmathsfont(Digits,Latin){Garamond MT Pro}
\setmathfont[range={\int}]{NewCMMath-Regular}
\setmonofont{Iosevka}
\setCJKmainfont{方正新书宋_GBK}[BoldFont={思源宋体 CN Bold}, ItalicFont={方正新楷体_GBK}, BoldItalicFont={汉仪颜楷 W}]
\setCJKsansfont{汉仪文黑-45W ExtraLight}[BoldFont={汉仪文黑-75W Bold}, ItalicFont={方正颜真卿楷书 简繁}]
\setCJKmonofont{霞鹭新晰黑}
%附加字体设置
\newCJKfontfamily{\kaico}{可口可乐在乎体 楷体}
\newCJKfontfamily{\kai}{方正新楷体_GBK}[BoldFont={汉仪颜楷 W}, ItalicFont={方正清刻本悦宋 简繁}, BoldItalicFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\yan}{方正清刻本悦宋 简繁}[ItalicFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\xiu}{方正宋刻本秀楷_GBK}[ItalicFont={方正宋刻本秀楷_GBK}, BoldFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\run}{汉仪润圆-45W ExtraLight}[BoldFont={汉仪润圆-75W Bold}, ItalicFont={汉仪润圆-45W ExtraLight}]
\newCJKfontfamily{\wen}{汉仪文黑-45W ExtraLight}[ItalicFont={汉仪文黑-75W Bold}, BoldFont={汉仪文黑-85W Heavy}, BoldItalicFont={汉仪文黑-85W Heavy}]
%文档格式
\geometry{left=2.24cm, right=2.24cm, top=3.18cm, bottom=3.18cm}
\linespread{1.4}
\numberwithin{equation}{section}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{4}
\renewcommand{\theparagraph}{\hskip2em\Alph{paragraph})}
\newcommand{\Section}[1]{ \refstepcounter{section} \section*{*\thesection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{section}{\makebox[0pt][r]{*}\thesection\texorpdfstring{\quad}{} #1} }
\newcommand{\Subsection}[1]{ \refstepcounter{subsection} \subsection*{*\thesubsection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{subsection}{\makebox[0pt][r]{*}\thesubsection\texorpdfstring{\quad}{} #1} }
\newcommand{\Subsubsection}[1]{ \refstepcounter{subsubsection} \subsubsection*{*\thesubsubsection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{subsubsection}{\makebox[0pt][r]{*}\thesubsubsection\texorpdfstring{\quad}{} #1} }
\setlist[itemize]{leftmargin=3em, labelsep=0.25em, itemindent=0em, itemsep=0pt, parsep=0pt, topsep=3pt, partopsep=0pt}
\setlist[description]{align=left, leftmargin=2em, itemindent=-1em, labelsep=1em, parsep=0pt, topsep=3pt, partopsep=0pt}
\setlength{\marginparwidth}{8em}
\setlength{\lineskip}{5pt}
\setlength{\lineskiplimit}{5pt}

\setlength{\abovecaptionskip}{0.3em}
\setlength{\belowcaptionskip}{0em}
\captionsetup[subfigure]{captionskip=0.5em, nearskip=0em}
\captionsetup[table]{justification=raggedright,singlelinecheck=false}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\renewcommand{\thetable}{\thesection.\arabic{table}}

\tikzset{every node/.style={scale=0.8}}
\ctikzset{monopoles/vcc/arrow={Stealth[width=4pt, length=6pt]}}
\ctikzset{monopoles/vee/arrow={Stealth[width=4pt, length=6pt]}}
\ctikzset{bipoles/length=1cm} %电路图大小标的
\ctikzset{resistors/thickness=2.5}
\ctikzset{voltage=raised}
\ctikzset{bipoles/cuteswitch/thickness=0.4}
\tikzset{ %元件着色
    R/.append style={color=balib},
    C/.append style={color=balib},
    L/.append style={color=balib},
    Do/.append style={color=balib},
    zDo/.append style={color=balib},
    leDo/.append style={color=balib},
    pDo/.append style={color=balib},
    battery1/.append style={color=meihong!75!black},
    battery2/.append style={color=meihong!75!black},
    battery/.append style={color=meihong!75!black},
    cI/.append style={color=meihong!75!black},
    I/.append style={color=meihong!75!black},
    cV/.append style={color=meihong!75!black},
    V/.append style={color=meihong!75!black},
}
\tikzset{bcirc/.style={circ, color=black}}
\tikzset{wcirc/.style={ocirc, color=black, fill=white}}
\ctikzset{
	*-*/.style = {bipole nodes={bcirc}{bcirc}},
	-*/.style = {bipole nodes={none}{bcirc}},
	*-/.style = {bipole nodes={bcirc}{none}},
	o-o/.style = {bipole nodes={wcirc}{wcirc}},
	-o/.style = {bipole nodes={none}{wcirc}},
	o-/.style = {bipole nodes={wcirc}{none}},
	o-*/.style = {bipole nodes={wcirc}{bcirc}},
	*-o/.style = {bipole nodes={bcirc}{wcirc}}
}
\ctikzset{logic ports=ieee}
\newcommand{\bi}[1]{% name
	\node [currarrow, color=black, anchor=center,
	rotate=\ctikzgetdirection{#1-Iarrow}] at (#1-Ipos) {};
}
\newcommand{\bv}[1]{% name
	\draw [color=black] (#1-Vfrom) .. controls (#1-Vcont1)
	and (#1-Vcont2).. (#1-Vto) node [currarrow,
	sloped, anchor=tip, allow upside down,pos=1]{};
}
\renewcommand{\bf}[1]{% name
	\draw [color=black] (#1-Ffrom) -- (#1-Fto) node [currarrow,
	sloped, anchor=tip, allow upside down,pos=1]{};
}
\ctikzset{!vi/.style={no v symbols, no i symbols, no f symbols}}
%\punctstyle{kaiming}
%定理环境
\theoremstyle{plain}
\newtheorem{theorem}{定理}[subsection]
\newtheorem{definition}{定义}[subsection]
\newtheorem{lemma}[theorem]{引理}
\newtheorem{corollary}[theorem]{推论}
\newtheorem{proposition}[theorem]{命题}

\theoremstyle{definition}
\newtheorem{examplein}[theorem]{\run 例题}
\newtheorem{circum}[theorem]{情形}

\newcommand{\exampleparameter}{0}
\newenvironment{example}[1][0]{% 0/1: no space; 2/3: 5pt space
	\renewcommand{\exampleparameter}{#1}
	\ifnum \exampleparameter>1
		\vspace{10pt}
	\fi
	\hrule
	\vspace{3pt}
	\noindent\hdashrule{\linewidth}{0.5pt}{2pt}
	\vspace{-2em}
	\begin{examplein}
}{% 0/2: -0.5pt space; 1/3: 5pt space
	\end{examplein}
	\vspace{-1em}
	\noindent\hdashrule{\linewidth}{0.5pt}{2pt}\vspace{3pt}
	\hrule
	\ifnum 1=\exampleparameter
		\vspace{10pt}
	\else
		\ifnum 3=\exampleparameter
			\vspace{10pt}
		\else
			\vspace{-0.5pt}
		\fi
	\fi
}

\newenvironment{proofs}[1][\small\proofname]{\begin{pf}[breakable, enhanced jigsaw]\begin{proof}[#1]\small\kai
	\abovedisplayskip=2pt
	\belowdisplayskip=2pt
}{\end{proof}\end{pf}}
\newenvironment{solution}[1][解]{\begin{proofs}[\small\textit{\yan #1}]\renewcommand{\qedsymbol}{$\circledS$}}{\end{proofs}}
\renewcommand{\proofname}{\yan{证明}}

\renewenvironment{cases}[1][l]{\left\{\,\begin{NiceArray}{#1}}{\end{NiceArray}\right.}
%颜色命名
\definecolor{meihong}{rgb}{0.85,0.2,0.47}
\definecolor{bali}{rgb}{0.2,0.6,0.78}
\definecolor{qinglv}{rgb}{0,0.35,0.32}
\definecolor{meihongb}{rgb}{0.85,0.2,0.47}
\definecolor{balib}{rgb}{0.15,0.45,0.58}
\definecolor{qinglvb}{rgb}{0,0.35,0.32}
%box环境
\newtcolorbox{pr}[2][]
{colback=black!5!white,colframe=white!75!black,fonttitle=\sffamily\wen\bfseries,title=#2,#1}
\newtcolorbox[use counter=definition,number within=subsection]{defi}[2][]
{colback=bali!5!white,colframe=bali!75!black,fonttitle=\sffamily\wen\bfseries,title=定义~\thetcbcounter. #2,#1}
\newtcolorbox[auto counter,number within=section]{compl}[2][]
{colback=bali!5!white,colframe=bali!65!black,fonttitle=\sffamily\wen\bfseries,label=#2,title=元件~\thetcbcounter. #2,#1, fontupper=\kai, fontlower=\kai}
\newtcolorbox[use counter=theorem,number within=subsection]{theo}[2][]
{%grow to right by=3.2cm,
colback=meihong!5!white,colframe=meihong!75!black,fonttitle=\sffamily\wen\bfseries,fontupper=\run,title=结论~\thetcbcounter. #2,#1}
\newtcolorbox[use counter=definition,number within=subsection]{defil}[2][]
{colback=bali!5!white,colframe=bali!75!black,fonttitle=\sffamily\wen\bfseries,label=#2,title=定义~\thetcbcounter. #2,#1}
\newtcolorbox[use counter=theorem,number within=subsection]{theol}[2][]
{%grow to right by=3.2cm,
colback=meihong!5!white,colframe=meihong!75!black,fonttitle=\sffamily\wen\bfseries,fontupper=\run,label=#2,title=结论~\thetcbcounter. #2,#1}
\newtcolorbox[auto counter,number within=section]{note}[2][]
{colback=qinglv!5!white,colframe=qinglv!75!black,fonttitle=\sffamily\wen\bfseries,title=注~\thetcbcounter. #2,#1}
\newtcbox{\prenote}[1][]
{left=0.25em,right=0.25em,top=0.25em,bottom=0.25em,width=8.5em,toptitle=0.1em,before skip=0pt,after skip=3pt,colback=gray!5!white,colframe=gray!50!black,fonttitle=\linespread{1}\raggedright\small\sf\bfseries,fontupper=\linespread{1}\small\sf,title=#1}
\newtcolorbox{pf}[1][]
{colback=black!5!white,colframe=white!75!black,#1}
\newtcolorbox{eq}[1][]
{standard jigsaw, colback=meihong!5!white, opacityback=0.7, %grow to right by=3.2cm, 
colframe=meihong!85!black,#1, boxrule=0.4pt, leftrule=10pt, arc=0pt, before skip=7pt, after skip=7pt}
%\newcommand{\mybox}[1]{\tikz[baseline=(MeNode.base)]{\node[rounded corners, fill=gray!20](MeNode){#1};}}
\newtcolorbox[auto counter]{eg}[2][]{colback=black!5!white,colframe=white!75!black, breakable, enhanced jigsaw, fontupper=\small, breakable, enhanced jigsaw, fonttitle=\sffamily\wen\bfseries, title=实例~\thetcbcounter\quad#2, #1}


\catcode`\，=\active
\def ，{\textup{,}\hskip0.5em }
\newcommand{\hang}[1][1]{\hangafter 1 \hangindent #1em \noindent}
\newcommand{\page}[1]{\hfill P$_\text{#1}$}
\newcommand{\colors}[1]{\color{#1!75!black}}
\newcommand{\paratitle}[1]{\hang \textbf{\wen #1}\hskip1em}
\newcommand{\tboqi}[1]{\textbf{\xiu\color{qinglv!75!black}#1}}
\newcommand{\mboqi}[1]{\symbf{\xiu\color{qinglv!75!black}#1}}
\newcommand{\tboba}[1]{\textbf{\kai\color{bali!75!black}#1}}
\newcommand{\mboba}[1]{\symbf{\kai\color{bali!75!black}#1}}
\newcommand{\tbome}[1]{\textbf{\run\run\color{meihong!75!black}#1}}
\newcommand{\mbome}[1]{\run\symbf{\run\color{meihong!75!black}#1}}
\newcommand{\adjline}{	\lineskiplimit=3pt
	\lineskip=3pt
	\abovedisplayskip=6pt
	\belowdisplayskip=6pt 
	}
\newcommand{\den}[2][]{\begin{defi}{#1}\adjline
	\kai #2\end{defi}}
\newcommand{\din}[2][]{\begin{theo}{#1}\adjline
	\run #2\end{theo}}
\newcommand{\de}[2][]{\begin{defil}{#1}\adjline
	\kai #2\end{defil}}
\newcommand{\di}[2][]{\begin{theol}{#1}\adjline
	\run #2\end{theol}}
\newcommand{\dep}[3][]{\begin{defi}{#1\page{#2}}\adjline
	\kai #3\end{defi}}
\newcommand{\dip}[3][]{\begin{theo}{#1\page{#2}}\adjline
	\run #3\end{theo}}
\newcommand{\zhu}[2][]{\begin{note}{#1}\adjline
	\xiu #2\end{note}}
\newcommand{\bu}[3][]{\begin{compl}{#1}	\paratitle{记号}#2 \tcblower\paratitle{特性}#3\end{compl}}
\newcommand{\trans}[3][2]{\begin{wrapfigure}[#1]{R}{8.7em}
		\vspace{-1.5em}
		\prenote[#2]{\parbox[l]{8em}{\raggedright #3}}
	\end{wrapfigure}}
% \newcommand{\tranS}[3][-1]{\marginnote{
% 		\begin{prenote}{#2}
% 			\raggedright
% 			#3
% 		\end{prenote}
% 	}[#1\baselineskip]}
\newcommand{\cbox}[2][]{
	$\vcenter{\hbox{\begin{circuitikz}[#1]
		#2
	\end{circuitikz}}}$
	}
\newcommand{\shbox}[1]{\cbox{\draw (0,0) to[#1] (1.5,0);}（\texttt{#1}）}
%定义算符
\newcommand{\rref}{\symup{rref}}
\newcommand{\C}{\mathbb{C}}
\renewcommand{\i}{\symsf{j}}
\newcommand{\neiji}[4]{\symbf{#1}_{#3}^\symup{T}\symbf{#2}_{#4}}
\def\upint{\mathchoice%
	{\mkern13mu\overline{\vphantom{\intop}\mkern7mu}\mkern-20mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	\int}
\def\lowint{\mkern3mu\underline{\vphantom{\intop}\mkern7mu}\mkern-10mu\int}
\renewcommand{\a}[1]{\left\langle #1 \right\rangle}
\renewcommand{\v}{\vee}
\newcommand{\A}{\wedge}
\renewcommand{\c}[1]{\symbfsfit{#1}}
\newcommand{\V}{\c{V}}
\newcommand{\I}{\c{I}}
\newcommand{\G}{\c{G}}
\newcommand{\Lr}{\Leftrightarrow}
\newcommand{\LLr}[2][]{\xLongleftrightarrow[#1]{#2}}
\newcommand{\rl}{\rightleftarrows}
\newcommand{\dif}{\mathop{}\!\symup{d}}
\newcommand{\Dif}{\mathop{}\!\symup{\Delta}}
\newcommand{\e}{\symup{e}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\dint}{\displaystyle\int}
\newcommand{\dt}[1][]{\dfrac{\dif #1}{\dif t}}
\renewcommand{\ang}[1]{\vcenter{\hbox{\begin{tikzpicture}
	\node (box) at (0,0) {$#1$};
	\draw (box.south west) ++ (-0.05,0.08) coordinate(left)
	(box.south east) ++ (-0.1,0.08) -- (left) -- ++ (0.17,0.45);
\end{tikzpicture}}}\!\!}
\newcommand{\meshcurrent}[2]{\draw[latex-] #1 node{#2} +(0.43,0.25) arc(30:330:0.5);
}
\newcommand{\equ}[1]{\begin{eq}
%	\setmathfont{GFSNeohellenicMath.otf}
	\setmathfont{FiraMath-Regular.otf}\sffamily
	\begin{equation}
		{\color{meihong!85!black} #1}
	\end{equation}\end{eq}
\setmathfont{KpMath-Regular.otf}
\setmathfont[range={\int}]{NewCMMath-Regular}
}
\newcommand{\mrm}[1]{{\symup{#1}}}
\newcommand{\uni}[1]{{\symup{\,#1}}}
%\setmathfont{Garamond-Math.otf}[StylisticSet={7,9}]}
%标题、作者、日期
\title
{
	\textbf{数字逻辑与处理器基础}{\kai 知识与方法}
}
\author{\zihao{5} T$^\text{T}$T}
\date{\zihao{5} \kai \today}
%----------------------------------------------------------
\begin{document}

\adjline

\maketitle
\begin{multicols}{2}
	\begin{flushleft}
		\tableofcontents
	\end{flushleft}
\end{multicols}

%\newgeometry{left=2.24cm, right=5.14cm, top=3.18cm, bottom=3.18cm}
\newpage
%----------------------------------------------------------
\section{布尔代数}

\subsection{数的编码与表示}

\de[二进制]{
	\tboba{二进制}是基数为2，只有两个数码0和1的数制。二进制数中，每一个数码称为一个二进制\tboba{位（bit）}，权值最小的二进制位称为\tboba{最低位（LSB）}，权值最大的二进制位称为\tboba{最高位（MSB）}。
}

所有的 4-bit 二进制数如表~\ref{Tab: 4-bit BIN}~所示。

\begin{table}[!ht]
	\caption{4-bit 二进制数}
	\label{Tab: 4-bit BIN}
	\begin{tabular}{cccccc}
		\toprule
		\multicolumn{4}{c}{\textbf{BIN}} & \textbf{DEC} & \textbf{HEX} \\
		\midrule
		0 & 0 & 0 & 0 & 0 & 0 \\
		0 & 0 & 0 & 1 & 1 & 1 \\
		0 & 0 & 1 & 0 & 2 & 2 \\
		0 & 0 & 1 & 1 & 3 & 3 \\
		0 & 1 & 0 & 0 & 4 & 4 \\
		0 & 1 & 0 & 1 & 5 & 5 \\
		0 & 1 & 1 & 0 & 6 & 6 \\
		0 & 1 & 1 & 1 & 7 & 7 \\
		\bottomrule
	\end{tabular} \(\quad\)
	\begin{tabular}{cccccc}
		\toprule
		\multicolumn{4}{c}{\textbf{BIN}} & \textbf{DEC} & \textbf{HEX} \\
		\midrule
		1 & 0 & 0 & 0 & 8 & 8 \\
		1 & 0 & 0 & 1 & 9 & 9 \\
		1 & 0 & 1 & 0 & 10 & A \\
		1 & 0 & 1 & 1 & 11 & B \\
		1 & 1 & 0 & 0 & 12 & C \\
		1 & 1 & 0 & 1 & 13 & D \\
		1 & 1 & 1 & 0 & 14 & E \\
		1 & 1 & 1 & 1 & 15 & F \\
		\bottomrule
	\end{tabular}
\end{table}

二进制数的\tboba{左移}运算和\tboba{右移}运算分别是将二进制数的所有位向左或向右移动一位，移动后的空位补0。左移一位相当于乘2，右移一位相当于除2。

\de[BCD码]{
	\tboba{BCD（binary-coded decimal）码}是二进制编码的一种，用4位二进制数表示一个十进制数的一位。
	
	\tboba{8421 BCD码}的编码规则是：用二进制数的0-9的编码表示十进制数的0-9，不使用二进制数的10-15的编码。
}

由于 8421 BCD码是\textbf{有权码}，其加减法运算可以直接使用二进制数和十进制数的加减法运算规则。

\begin{example}[3]
	（1）\(34_{10} + 45_{10} = 0011\,0100_{BCD} + 0100\,0101_{BCD} = 0111\,1001_{BCD} = 79_{10}\)。

	（2）\(14_{10} + 9_{10} = 0001\,0100_{BCD} + 0000\,1001_{BCD} = 0001\,1101_{BCD} \xlongequal{\text{进位}} = 0010\,0011_{BCD} = 23_{10}\)。
\end{example}

8个二进制位称为一个\tboba{字节}。

\section{逻辑计算}

\subsection{从电路到逻辑门}

\de[逻辑门]{
	\tboba{逻辑门}是一种能够实现逻辑运算的电路，其输入和输出均为逻辑值。逻辑门的输入和输出均为二进制数，输入的二进制数称为\tboba{输入变量}，输出的二进制数称为\tboba{输出变量}。
}

常用的逻辑门如表~\ref{Tab: Logic Gate}~所示。

\begin{table}[!ht]
	\caption{常用逻辑门}
	\label{Tab: Logic Gate}
	\begin{tabular}{cccc}
		\toprule
		\textbf{逻辑门} & \textbf{符号} & \textbf{记号} & \textbf{运算} \\
		\midrule
		非门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[not port, anchor=in](G){} (G.out) node[right]{\(Y\)};
		} & NOT & \(Y = A'\) \tablefootnote{
			为区别单个的非逻辑和其他多目运算中的非，这里约定单独的非逻辑用\(A'\)表示，夺目运算附带的非逻辑用\(\overline{A}\)表示。
		} \\[1em]
		与非门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[nand port, anchor=in 1](G){} (G.out) node[right]{\(Y\)} (G.in 2) node[left]{\(B\)};
		} & NAND & \(Y = \overline{A \cdot B}\) \\[1em]
		或非门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[nor port, anchor=in 1](G){} (G.out) node[right]{\(Y\)} (G.in 2) node[left]{\(B\)};
		} & NOR & \(Y = \overline{A + B}\) \\[1em]
		异或非门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[xnor port, anchor=in 1](G){} (G.out) node[right]{\(Y\)} (G.in 2) node[left]{\(B\)};
		} & XNOR & \(Y = \overline{A \oplus B}\) \\[0.5em]
		\bottomrule
	\end{tabular} \(\quad\)
	\begin{tabular}{cccc}
		\toprule
		\textbf{逻辑门} & \textbf{符号} & \textbf{记号} & \textbf{运算} \\
		\midrule
		缓冲器 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[buffer port, anchor=in 1](G){} (G.out) node[right]{\(Y\)};
		} & BUF & \(Y = A\) \\[1em]
		与门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[and port, anchor=in 1](G){} (G.out) node[right]{\(Y\)} (G.in 2) node[left]{\(B\)};
		} & AND & \(Y = A \cdot B\) \\[1em]
		或门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[or port, anchor=in 1](G){} (G.out) node[right]{\(Y\)} (G.in 2) node[left]{\(B\)};
		} & OR & \(Y = A + B\) \\[1em]
		异或门 & \cbox{
			\draw (0,0) node[left]{\(A\)} node[xor port, anchor=in 1](G){} (G.out) node[right]{\(Y\)} (G.in 2) node[left]{\(B\)};
		} & XOR & \(Y = A \oplus B\) \\[0.5em]
		\bottomrule
	\end{tabular}
\end{table}

\bu[传输门]{
	\cbox{\draw (0,0) node[left]{\(A \)} node[double tgate, anchor=in](G){} (G.out) node[right]{\(Y\)} (G.up) ++(0,0.15) node[above]{\(\overline{B}\)} (G.down) ++(0,-0.2) node[below]{\(B\)}; }
}{
	传输门是一种多输入单输出的逻辑门，其输出为
	\[
		Y = \begin{cases}[ll]
			A， & B = 1 \\
			\mathrm{undefined}， & B = 0
		\end{cases}
	\]
}

\subsection{组合逻辑}

\de[组合逻辑]{
	\tboba{组合逻辑}是一种逻辑电路，其输出仅取决于当前的输入及延时，与电路的历史状态无关。组合逻辑电路中没有反馈回路。
}

\subsubsection{组合逻辑电路的分析方法}

分析组合逻辑电路，即是从给定的设计电路（晶体管或逻辑门电路）中，找出输入与输出之间的关系，用真值表、布尔表达式等形式表示。

\begin{example}[2]
	分析如图~\ref{Fig: Combinational Logic Circuit 1}~所示的组合逻辑电路。
	\begin{figure}[!ht]
		\centering
		\subfloat[逻辑电路]{
			\label{Fig: Combinational Logic Circuit 1}
			\begin{adjustbox}{valign=b}
				\includegraphics[scale=0.25]{Circuits/FIG-Combinational_Logic_Circuit_1.drawio.png}
			\end{adjustbox}
		}
		\quad
		\subfloat[真值表]{
			\belowrulesep=0pt
			\aboverulesep=0pt
			\label{Tab: Combinational Logic Circuit 1}
			\begin{tabular}[b]{ccc|ccc}
				\toprule
				\(\symbf{A}\) & \(\symbf{B}\) & \(\symbf{C}\) & \(\symbf{F_0}\) & \(\symbf{F_1}\) & \(\symbf{F_2}\) \\
				\midrule
				0 & 0 & 0 & 0 & 0 & 1 \\
				0 & 0 & 1 & 0 & 1 & 0 \\
				0 & 1 & 0 & 0 & 1 & 1 \\
				0 & 1 & 1 & 1 & 0 & 0 \\
				1 & 0 & 0 & 1 & 0 & 1 \\
				1 & 0 & 1 & 1 & 1 & 0 \\
				1 & 1 & 0 & 1 & 1 & 1 \\
				1 & 1 & 1 & 0 & 0 & 0 \\
				\bottomrule
			\end{tabular}
		}
		\caption{组合逻辑电路实例 1}
	\end{figure}
	\begin{solution}
		根据逻辑门的运算规则，可得到
		\[
			\begin{cases}
				F_0 = A \oplus (B \cdot C) \\
				F_1 = B \oplus C \\
				F_2 = \overline{C}
			\end{cases}
		\]
		因此，该组合逻辑电路输出的真值表如表~\ref{Tab: Combinational Logic Circuit 1}~所示。
		可以看出，这个电路所实现的功能为 \((F_0F_1F_2)_2 = (ABC)_2 + 1\)，这是一个 3-bit 二进制自增电路。
	\end{solution}
\end{example}

\begin{example}[1]
	分析如图~\ref{Fig: Combinational Logic Circuit 2}~所示的组合逻辑电路。
	\begin{figure}[!ht]
		\centering
		\subfloat[逻辑电路]{
			\label{Fig: Combinational Logic Circuit 2}
			\begin{adjustbox}{valign=b}
				\includegraphics[scale=0.25]{Circuits/FIG-Combinational_Logic_Circuit_2.drawio.png}
			\end{adjustbox}
		}
		\quad
		\subfloat[真值表]{
			\belowrulesep=0pt
			\aboverulesep=0pt
			\begin{tabular}[b]{ccc|ccc}
				\toprule
				\(\symbf{A}\) & \(\symbf{B}\) & \(\symbf{C}\) & \(\symbf{D}\) & \(\symbf{F_0}\) & \(\symbf{F_1}\) \\
				\midrule
				0 & 0 & 0 & 0 & 0 & 1 \\
				0 & 0 & 1 & 0 & 1 & 1 \\
				0 & 1 & 0 & 1 & 1 & 0 \\
				0 & 1 & 1 & 0 & 1 & 0 \\
				1 & 0 & 0 & 0 & 0 & 0 \\
				1 & 0 & 1 & 1 & 0 & 0 \\
				1 & 1 & 0 & 1 & 1 & 1 \\
				1 & 1 & 1 & 1 & 0 & 1 \\
				\bottomrule
			\end{tabular}
			\label{Tab: Combinational Logic Circuit 2}
		}
		\caption{组合逻辑电路实例 2}
	\end{figure}
	\begin{solution}
		根据逻辑门的运算规则，可得到
		\[
			\begin{cases}
				F_0 = \overline{\overline{AC} \cdot \overline{B\overline{c}}} \\
				F_1 = \overline{\overline{B\overline{C}} \cdot \overline{C\overline{A}}} \\
				F_2 = \overline{(A+B) \cdot \overline{AB}}
			\end{cases}
		\]
		因此，该组合逻辑电路输出的真值表如表~\ref{Tab: Combinational Logic Circuit 2}~所示，这是一个 Gray 码递增电路。
	\end{solution}
\end{example}

\subsubsection{组合逻辑电路的设计过程}

设计一个组合逻辑电路，需要将算法转化为二元逻辑的计算，化简后用逻辑电路结构实现。

\begin{example}[3]
	设计一个 2-bit 比较器。
	\begin{solution}
		2-bit 比较器的设计需求为：
		\begin{itemize}
			\item 功能：比较两个 2-bit 二进制数的大小；
			\item 输入：两个 2-bit 二进制数 \(A_1A_0\) 和 \(B_1B_0\)；
			\item 输出：三个逻辑值 \(LT\)、\(EQ\) 和 \(GT\)，分别表示 \(A < B\)、\(A = B\) 和 \(A > B\)。
		\end{itemize}
		用卡诺图表示出 \(LT\)、\(EQ\) 和 \(GT\) 的逻辑表达式如表~\ref{Tab: 2-bit Comparator}~所示，即知其两级与或表达式为
		\begin{align*}
			& LT = A_1'B_1 + A_1'A_0'B_0 + A_0'B_1B_0 \\
			& EQ = A_1'A_0'B_1'B_0' + A_1'A_0B_1'B_0 + A_1A_0'B_1B_0' + A_1A_0B_1B_0 \\
			& GT = A_1B_1' + A_1B_1'B_0' + A_1A_0B_0'
		\end{align*}
		其中 \(EQ\) 可以更简单地表示为
		\[
			EQ = \overline{A_1 \oplus B_1} \cdot \overline{A_0 \oplus B_0}
		\]
		或者利用另外两个输出的逻辑表达式，即
		\[
			EQ = \overline{LT + GT}
		\]
		将 \(LT\)、\(EQ\) 和 \(GT\) 的逻辑表达式转化为逻辑电路，即可得到 2-bit 比较器的设计。
	\end{solution}
	\begin{table}[!ht]
		\belowrulesep=0pt
		\aboverulesep=0pt
		\caption{2-bit 比较器设计的卡诺图}
		\label{Tab: 2-bit Comparator}
		\subfloat[\(LT\)]{
			\begin{tabular}{c|cccc}
				\toprule
				\(A_1A_0 \backslash B_1B_0\) & 00 & 01 & 11 & 10 \\
				\midrule
				00 &   & 1 & 1 & 1 \\
				01 &   &   & 1 & 1 \\
				11 &   &   &   &   \\
				10 &   &   & 1 &   \\
				\bottomrule
			\end{tabular}
		}
		\subfloat[\(EQ\)]{
			\begin{tabular}{c|cccc}
				\toprule
				\(A_1A_0 \backslash B_1B_0\) & 00 & 01 & 11 & 10 \\
				\midrule
				00 & 1 &   &   &   \\
				01 &   & 1 &   &   \\
				11 &   &   & 1 &   \\
				10 &   &   &   & 1 \\
				\bottomrule
			\end{tabular}
		}
		\subfloat[\(GT\)]{
			\begin{tabular}{c|cccc}
				\toprule
				\(A_1A_0 \backslash B_1B_0\) & 00 & 01 & 11 & 10 \\
				\midrule
				00 &   &   &   &   \\
				01 & 1 &   &   &   \\
				11 & 1 & 1 &   & 1 \\
				10 & 1 & 1 &   &   \\
				\bottomrule
			\end{tabular}
		}
	\end{table}
\end{example}


如上 4-bit 输入的逻辑运算已经比较复杂。对于更加复杂的逻辑运算，在处理中需要采取更多的技巧以简化运算，如：
\begin{itemize}
	\item 将输入变量分组，写成更简单的逻辑表达式的多级运算：
	\[
		f(A，B，C，\cdots) = F(g_1(A，B，\cdots)，g_2(C，\cdots)，\cdots)
	\]
	\item 将输入变量分离，写成更简单的逻辑表达式的分支计算：
	\[
		f(A，B，C，\cdots) = A \cdot g_1(B，C，\cdots) + \overline{A} \cdot g_2(B，C，\cdots)
	\]
	\item 从结构化表达式中找出重复的部分加以复用，简化逻辑电路。
\end{itemize} 
同时，还需要照应到实际的功耗、性能、面积等要求。

\subsubsection{组合逻辑电路的评价指标}

评价逻辑电路的主要指标包括：
\begin{itemize}
	\item 稳态因素：
	\begin{itemize}
		\item \textbf{逻辑电平}：逻辑电路的输入和输出电平高低；
		\item \textbf{噪声容限}：逻辑电路抵抗噪声的能力；
		\item \textbf{静态功耗}：逻辑电路在稳态工作时的功耗，主要与电路的 \(V_{CC}\) 有关；
		\item \textbf{面积}：逻辑电路的物理尺寸；
		\item \textbf{扇出系数}：逻辑门的输出能够驱动的输入数量。
	\end{itemize}
	\item 动态因素：
	\begin{itemize}
		\item \textbf{传输延迟}和\textbf{时钟频率}：逻辑电路的输入到输出的延迟时间；
		\item \textbf{时序容限}：逻辑电路的输入信号的时序要求；
		\item \textbf{动态功耗}：逻辑电路在工作时的功耗，主要与电路的切换频率有关；
		\item \textbf{噪声}：逻辑电路在工作时产生的噪声。
	\end{itemize}
\end{itemize}

\subsubsection{组合逻辑电路的设计实例}

\paragraph{编码器（Encoder）和译码器（Decoder）}

用 \(m\) 个二进制位对 \(n \le 2^m\) 个输入信号进行编码，得到 \(m\) 位二进制代码的电路，称为 \,\(\mboba{2^m - m}\)\,\tboba{线编码器}。

\begin{example}[3]
	设计一个 \(4-2\) 线编码器用作抢答器，其中每个抢答按钮按下时对应输入信号为1，其余输入信号为0。
	\begin{solution}
		4 个输入信号的抢答器的真值表如表~\ref{Tab: 4-2 Encoder}~所示\footnote{
			由于编码器的输入信号类型数最多为输出信号所能表示的最大数值，其必定要用\textbf{无关项}的形式归总一些设计之外的情况。考虑到输出信号的唯一性，表中无关项的分布不是对称的。
		}，容易得到其逻辑表达式为
		\begin{align*}
			& Y_0 = A_3 + A_1 \\[-3pt]
			& Y_1 = A_3 + A_2
		\end{align*}
		该编码器的设计如图~\ref{Fig: 4-2 Encoder}~所示。

		但是，这个编码器不能满足抢答器的优先要求。为了实现优先级，可以将输入信号的优先级从高到低排列，然后将优先级高的输入信号的输出信号设为1，优先级低的输入信号的输出信号设为0。具体的电路设计略。
	\end{solution}
	\begin{figure}[!ht]
		\belowrulesep=0pt
		\aboverulesep=0pt
		\centering
		\subfloat[真值表]{
			\label{Tab: 4-2 Encoder}
			\begin{tabular}[b]{cccc|cc}
				\toprule
				\(A_3\) & \(A_2\) & \(A_1\) & \(A_0\) & \(Y_1\) & \(Y_0\) \\
				\midrule
				\(\times\) & \(\times\) & \(\times\) & 1 & 0 & 0 \\
				\(\times\) & \(\times\) & 1 & 0 & 0 & 1 \\
				\(\times\) & 1 & 0 & 0 & 1 & 0 \\
				1 & 0 & 0 & 0 & 1 & 1 \\
				\bottomrule
			\end{tabular}
		}
		\quad
		\subfloat[逻辑电路]{
			\label{Fig: 4-2 Encoder}
			\begin{adjustbox}{valign=b}
				\includegraphics[scale=0.25]{Circuits/FIG-4-2_Encoder.drawio.png}
			\end{adjustbox}
		}
		\caption{\(4-2\) 线编码器设计}
		\vspace{-2em}
	\end{figure}
\end{example}

译码是编码的逆过程，即将编码后的信号转换为原始信号。用 \(n\) 个二进制位对 \(m \le log_2 n\) 个输入信号进行译码，得到 \(n\) 位二进制代码的电路，称为 \,\(\mboba{log_2 n - n}\)\,\tboba{线译码器}。

\paragraph{多路选择器（Multiplexer，MUX）}

用 \(n\) 个控制信号对 \(2^n\) 个输入信号进行选择，得到一个输出信号的电路，称为 \,\(\mboba{2^n : 1}\)\,\tboba{多路选择器}。

\begin{example}[3]
	设计一个 \(4 : 1\) 多路选择器。
	\begin{solution}
		4 : 1 多路选择器的真值表如表~\ref{Tab: 4-1 MUX}~所示，容易得到其逻辑表达式为
		\[
			Q = A_1'A_0'D_0 + A_1'A_0D_1 + A_1A_0'D_2 + A_1A_0D_3
		\]
		如图~\ref{Fig: 4-1 MUX}，该多路选择器的每一个输入信号都与一组控制信号相与，各组中当且仅当输入控制信号全都对应时，输出信号为对应的输入信号。
	\end{solution}
	\begin{figure}[!ht]
		\vspace{-2em}
		\belowrulesep=0pt
		\aboverulesep=0pt
		\centering
		\subfloat[真值表]{
			\label{Tab: 4-1 MUX}
			\begin{tabular}[b]{cc|c}
				\toprule
				\(A_1\) & \(A_0\) & \(Q\) \\
				\midrule
				0 & 0 & \(D_0\) \\
				0 & 1 & \(D_1\) \\
				1 & 0 & \(D_2\) \\
				1 & 1 & \(D_3\) \\
				\bottomrule
			\end{tabular}
		}
		\quad
		\subfloat[逻辑电路]{
			\label{Fig: 4-1 MUX}
			\begin{adjustbox}{valign=b}
				\includegraphics[scale=0.25]{Circuits/FIG-4-1_MUX.drawio.png}
			\end{adjustbox}
		}
		\quad
		\subfloat[记号]{
			\begin{adjustbox}{valign=b}
				\includegraphics[scale=0.25]{Circuits/FIG-4-1_MUX_Symbol.drawio.png}
			\end{adjustbox}
		}
		\caption{\(4 : 1\) 多路选择器设计}
		\vspace{-1em}
	\end{figure}
\end{example}

\begin{eg}{移位器}
	采用多路选择器可以实现移位运算。如图~\ref{Fig: 4-bit Shifter}~所示，一个 4-bit 右移位器可以通过 8 个 2 : 1 多路选择器实现。其中，\(S_0\) 控制右移 1 位，\(S_1\) 控制右移 2 位，当 \({S_1S_0}_{(2)} = 11_{(2)}\) 时即右移 3 位。换句话说，控制信号形成的二进制数表示右移的位数。右移后，高位补入 \(\mrm{MSB}\) 的值，通常对正数补 0，对负数补 1。
\end{eg}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.25]{Circuits/FIG-4-bit_Shifter.drawio.png}
	\caption{4-bit 右移位器}
	\label{Fig: 4-bit Shifter}
\end{figure}

\paragraph{加法器}

用于实现二进制数的加法运算。

\begin{example}[3]
	设计一个 1-bit 全加器电路。
	\begin{solution}
		1-bit 全加器有 3 个输入信号（ \(A\)、\(B\) 和进位信号 \(C_\mrm{in}\)）、2 个输出信号（本位的和 \(S\) 、进位输出信号\(C_\mrm{out}\)，其真值表如表~\ref{Tab: 1-bit Full Adder}~所示。根据真值表，可以得到 1-bit 全加器的逻辑表达式为
		\begin{align*}
			& S = A \oplus B \oplus C_\mrm{in} \\
			& C_\mrm{out} = AB + BC_\mrm{in} + AC_\mrm{in}
		\end{align*}
		该 1-bit 全加器的设计如图~\ref{Fig: 1-bit Full Adder}~所示。
	\end{solution}
	\begin{figure}[!ht]
		\belowrulesep=0pt
		\aboverulesep=0pt
		\centering
		\subfloat[真值表]{
			\label{Tab: 1-bit Full Adder}
			\begin{tabular}[b]{ccc|cc}
				\toprule
				\(A\) & \(B\) & \(C_\mrm{in}\) & \(S\) & \(C_\mrm{out}\) \\
				\midrule
				0 & 0 & 0 & 0 & 0 \\
				0 & 0 & 1 & 1 & 0 \\
				0 & 1 & 0 & 1 & 0 \\
				0 & 1 & 1 & 0 & 1 \\
				1 & 0 & 0 & 1 & 0 \\
				1 & 0 & 1 & 0 & 1 \\
				1 & 1 & 0 & 0 & 1 \\
				1 & 1 & 1 & 1 & 1 \\
				\bottomrule
			\end{tabular}
		}
		\quad
		\subfloat[逻辑电路]{
			\label{Fig: 1-bit Full Adder}
			\begin{adjustbox}{valign=b}
				\includegraphics[scale=0.25]{Circuits/FIG-1-bit_Full_Adder.drawio.png}
			\end{adjustbox}
		}
	\end{figure}
\end{example}

将 1-bit 全加器串联，可得到一种 4-bit 全加器的设计，如图~\ref{Fig: 4-bit Ripple Carry Adder}~所示，这称为\tboba{行波进位加法器（ripple carry adder）}。

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.25]{Circuits/FIG-4-bit_Ripple_Carry_Adder.drawio.png}
	\caption{4-bit 行波进位加法器}
	\label{Fig: 4-bit Ripple Carry Adder}
\end{figure}

\subsection{时序逻辑}

\subsubsection{时序逻辑电路的基本概念}

\paragraph{触发与节拍信号}

用\textbf{时钟信号}控制逻辑电路的运行，使其在时钟信号的\textbf{节拍}下按照一定的顺序依次\textbf{触发}响应进行逻辑运算，这种电路称为\tboba{时序逻辑电路}。

\begin{definition}
	\tboba{时钟信号发生器}是一种能够产生连续的方波信号的电路。
\end{definition}

用\textbf{奇数个}反相器可以串联成环形振荡器，若串联的反相器个数为 \(n\)，每个反相器的延迟时间为 \(t_\mrm{pd}\)，则环形振荡器的周期为 \(T = 2n \cdot t_\mrm{pd}\)。因此，环形振荡器是一种简单的时钟信号发生器。

基于时钟信号，在边缘（如上升沿）采样输入信号、更新状态，可以实现时序逻辑。

\begin{definition}
	使信号事件与时钟节拍一致的操作称为\tboba{同步}，所有同步于同一个时钟信号的信号集合称为\tboba{时钟域}。
\end{definition}

\paragraph{状态与有限状态机}

一个系统的\tboba{状态（state）}应包含所有需要的信息而可以有冗余信息。依据输入信号和当前状态，系统的输出信号和下一个状态是确定的。

\de[有限状态机]{
	\tboba{有限状态机（finite state machine，FSM）}是一种能够根据输入信号和当前状态，确定输出信号和下一个状态的系统。

	描述一个 FSM 需要确定 6 大要素：
	\begin{itemize}
		\item 状态集合 State，FSM 的所有可能状态；
		\item 初始状态 \(S_0\)，FSM 启动及复位时的状态；
		\item 输入信号 Input；
		\item 输出信号 Output；
		\item 输出函数 \(f\)，描述 FSM 的输出信号与输入信号和当前状态的关系；
		\item 状态转移函数 \(g\)，描述 FSM 的下一个状态与输入信号和当前状态的关系。
	\end{itemize}
}

FSM 有两种类型：\tboba{Moore FSM} 和 \tboba{Mealy FSM}。Moore FSM 的输出只与当前状态有关，而 Mealy FSM 的输出与当前状态和输入信号有关。两种 FSM 的状态转移函数 \(g\) 都可以用\tboba{状态转换表（state transition table）}表示，如表~\ref{Tab: General State Transition Table}~所示；或者用\tboba{状态转换图（state transition diagram）}表示，如图~\ref{Fig: General State Transition Diagram}~所示。

\begin{table}[!ht]
	\belowrulesep=0pt
	\aboverulesep=0pt
	\caption{一般的状态转换表}
	\label{Tab: General State Transition Table}
	\subfloat[Moore FSM]{
		\begin{tabular}{c|cccc|c}
			\toprule
			\multirow{2}{*}{\textbf{State}} & \multicolumn{4}{c|}{\textbf{Input}} & \multirow{2}{*}{\textbf{Output}} \\
			& \(I_1\) & \(I_2\) & \(\cdots\) & \(I_n\) & \\ 
			\midrule
			\(S_1\) & \(S_a\) & \(S_b\) & \(\cdots\) & \(S_c\) & \(O_1\) \\
			\(S_2\) & \(S_d\) & \(S_e\) & \(\cdots\) & \(S_f\) & \(O_2\) \\
			\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\vdots\) \\
			\(S_m\) & \(S_x\) & \(S_y\) & \(\cdots\) & \(S_z\) & \(O_m\) \\
			\bottomrule
		\end{tabular}
	}
	\quad
	\subfloat[Mealy FSM]{
		\begin{tabular}{c|cccc}
			\toprule
			\multirow{2}{*}{\textbf{State}} & \multicolumn{4}{c}{\textbf{Input}} \\
			& \(I_1\) & \(I_2\) & \(\cdots\) & \(I_n\)\\ 
			\midrule
			\(S_1\) & \(S_a，O_a\) & \(S_b，O_b\) & \(\cdots\) & \(S_c，O_c\) \\
			\(S_2\) & \(S_d，O_d\) & \(S_e，O_e\) & \(\cdots\) & \(S_f，O_f\) \\
			\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) \\
			\(S_m\) & \(S_x，O_x\) & \(S_y，O_y\) & \(\cdots\) & \(S_z，O_z\) \\
			\bottomrule
		\end{tabular}
	}
\end{table}

\begin{figure}[!ht]
	\centering
	\subfloat[Moore FSM]{
		\label{Fig: Moore State Transition Diagram}
		\includegraphics[scale=0.25]{Circuits/FIG-Moore_State_Transition_Diagram.drawio.png}
	}
	\quad
	\subfloat[Mealy FSM]{
		\label{Fig: Mealy State Transition Diagram}
		\includegraphics[scale=0.25]{Circuits/FIG-Mealy_State_Transition_Diagram.drawio.png}
	}
	\caption{一般的状态转换图}
	\label{Fig: General State Transition Diagram}
\end{figure}


\subsubsection{锁存器和寄存器}

\paragraph{锁存器}
　
\de[锁存器]{
	\tboba{锁存器（latch）}是一个存储1-bit状态的电路单元，其输出信号可以保持，直到特定的输入信号触发重置或写入。
}

依据具体实现方式，锁存器可以分为 SR 锁存器、D 锁存器等类型。

\bu[SR锁存器]{
	\(\vcenter{\hbox{
		\includegraphics[scale=0.25]{Circuits/FIG-SR_Latch.drawio.png}
	}}\)
	
}{
	下一个输出信号 \(Q^+\) 与输入信号 \(R\)、\(S\) 和当前输出信号 \(Q\) 的关系为 \(Q^+ = S + R'Q\)，其中 \(SR = 0\)。
}

用门电路实现 SR 锁存器，如图~\ref{Fig: SR Latch Circuit}~所示。

\begin{figure}[!ht]
	\centering
	\subfloat[逻辑电路]{
		\label{Fig: SR Latch Circuit}
		\begin{adjustbox}{valign=b}
			\includegraphics[scale=0.25]{Circuits/FIG-SR_Latch_Circuit.drawio.png}
		\end{adjustbox}
	}
	\quad
	\subfloat[真值表]{
		\aboverulesep=0pt
		\belowrulesep=0pt
		\label{Tab: SR Latch}
		\begin{tabular}[b]{cc|p{2em}<{\centering}p{2em}<{\centering}}
			\toprule
			\(S\) & \(R\) & \(Q^+\) & \(Q'^+\) \\
			\midrule
			0 & 0 & \(\symbf{Q}\) & \(\symbf{Q'}\) \\
			0 & 1 & 0 & 1 \\
			1 & 0 & 1 & 0 \\
			1 & 1 & \multicolumn{2}{c}{undefined} \\
			\bottomrule
		\end{tabular}
	}
	\caption{SR锁存器}
\end{figure}

\zhu[要求 \(\symbf{SR = 0}\) 的原因]{
	当 \(S = R = 1\) 时，SR 锁存器的输出保持 \(Q = Q' = 0\)，这不符合输出的逻辑要求；并且，此后若 \(S\) 和 \(R\) 同时变为 0，输出信号将不稳定，可能导致电路失效。因此，SR 锁存器的真值表如表~\ref{Tab: SR Latch}~所示。
}

可以给 SR 锁存器加上门控使能信号，如图~\ref{Fig: Gated SR Latch}~所示，仅当使能信号 \(C = 1\) 时，SR 锁存器才能改变状态。在门控信号上加上时钟信号 CLK，就可以实现对输入的定时采样。其 \(Q^+\) 与 \(Q\) 的关系可写为
\[
	Q^+ = C \cdot (S + R'Q) + C'Q
\]

\begin{figure}[!ht]
	\centering
	\subfloat[逻辑电路]{
		\label{Fig: Gated SR Latch Circuit}
		\includegraphics[scale=0.25]{Circuits/FIG-Gated_SR_Latch_Circuit.drawio.png}
	}
	\quad
	\subfloat[记号]{
		\includegraphics[scale=0.25]{Circuits/FIG-Gated_SR_Latch.drawio.png}
	}
	\caption{门控SR锁存器}
	\label{Fig: Gated SR Latch}
\end{figure}

\bu[D锁存器]{
	\(\vcenter{\hbox{
		\includegraphics[scale=0.25]{Circuits/FIG-D_Latch.drawio.png}
	}}\)
}{
	\(C = 1\) 时，下一个输出信号 \(Q^+\) 与输入信号 \(D\) 的关系为 \(Q^+ = D\)，即输出跟踪输入；\(C = 0\) 时，输出信号保持。
}

用门电路实现 D 锁存器，如图~\ref{Fig: D Latch LG}~所示。此外，也可以用传输门和非门实现 D 锁存器，如图~\ref{Fig: D Latch TG}~所示。

\begin{figure}[!ht]
	\centering
	\subfloat[逻辑门实现]{
		\label{Fig: D Latch LG}
		\includegraphics[scale=0.25]{Circuits/FIG-D_Latch_Circuit_By_LG.drawio.png}
	}
	\quad
	\subfloat[传输门实现]{
		\label{Fig: D Latch TG}
		\includegraphics[scale=0.25]{Circuits/FIG-D_Latch_Circuit_By_TG.drawio.png}
	}
	\caption{D锁存器}
\end{figure}

\zhu[门控SR锁存器和D锁存器的时序差异]{
	门控SR锁存器和D锁存器都是\tboqi{在信号\(\mboqi{C}\)的下降沿}时锁定，但后者的锁定输出只与\tboqi{下降沿的输入}有关，而前者的锁定输出还受到\tboqi{\,\(\mboqi{S}\)与\(\mboqi{R}\)都为低电平}前的输入的影响。
}

\zhu[锁存器的时序参数]{
	锁存器的性能受到以下几个时序参数的影响：
	\begin{itemize}
		\item \tboqi{最小脉冲宽度}：能够稳定锁存的最短输入脉冲宽度，记作 \(t_{\mrm{w(min)}}\)；
		\item \tboqi{延迟时间}：输入信号发生变化到输出信号发生变化的时间，记作 \(t_{\mrm{pd}}\)，分为 \tboqi{上升延迟时间} \(t_{\mrm{pLH}}\) 和 \tboqi{下降延迟时间} \(t_{\mrm{pHL}}\)；
		\item \tboqi{建立时间}、\tboqi{保持时间}：锁存操作开始、结束之前、之后输入信号需要保持的时间，分别记作 \(t_{\mrm{su}}\) 和 \(t_{\mrm{h}}\)。如果信号不满足建立时间和保持时间约束，输出结果会呈现不确定的\tboqi{亚稳态}。
	\end{itemize}
	各个参数的具体定义如图~\ref{Fig: Timing Parameters of Latch}~所示。
}

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.25]{Circuits/FIG-Timing_Parameters_of_Latch.drawio.png}
	\caption{锁存器的时序参数}
	\label{Fig: Timing Parameters of Latch}
\end{figure}

\paragraph{触发器}
　
\de[触发器]{
	\tboba{触发器（flip-flop）}是一种\textbf{只在触发沿}把输入信号写入输出信号的电路。
}

\bu[D 触发器（DFF）]{
	\(\vcenter{\hbox{
		\includegraphics[scale=0.25]{Circuits/FIG-D_Flip-Flop.drawio.png}
	}}\)
}{
	在时钟信号 \(C\) 的上升沿，下一个输出信号 \(Q^+\) 与输入信号 \(D\) 的关系为 \(Q^+ = D\)；其他时间，输出信号保持。
}

DFF 的一种常见的实现方式是两个 D 锁存器级联，如图~\ref{Fig: D Flip-Flop Circuit}~所示，其中左侧的 D 锁存器用于存储输入信号，称为\tboba{主锁存器}；右侧的 D 锁存器用于控制输出信号，称为\tboba{从锁存器}。

\begin{figure}[!ht]
	\centering
	\subfloat[逻辑电路]{
		\label{Fig: D Flip-Flop Circuit}
		\includegraphics[scale=0.25]{Circuits/FIG-D_Flip-Flop_Circuit.drawio.png}
	}\\
	\subfloat[时序图]{
		\label{Fig: D Flip-Flop Timing Diagram}
		\includegraphics[scale=0.25]{Circuits/FIG-D_Flip-Flop_Timing_Diagram.drawio.png}
	}
	\caption{D触发器}
\end{figure}

在一个时钟周期中，时钟信号 \(C\) 为低电平时，主锁存器的输出信号 \(Q_M\) 随输入信号 \(D\) 变化，从锁存器的输出信号 \(Q\) 保持不变；时钟信号 \(C\) 为高电平时，主锁存器的输出信号 \(Q_M\) 保持不变，从锁存器的输出信号 \(Q\) 将 \(Q_M\) 的值输出。因此，在 \(C\) 的上升沿，DFF 表现为将输入信号 \(D\) 写入输出信号 \(Q\) 锁存一个周期。DFF 的时序图如图~\ref{Fig: D Flip-Flop Timing Diagram}~所示。

\zhu[DFF 的时序参数]{
	DFF 的时序参数与锁存器类似，包括：
	\begin{itemize}[leftmargin=1em]
		\item \tboqi{建立时间} \(\mboqi{t_{\mrm{su}}}\)：输入信号在时钟信号上升沿前需要传输到 \(T_2\) 两端以避免竞争，这一过程所需要保持的时间；
		\item \tboqi{保持时间} \(\mboqi{t_{\mrm{h}}}\)：输入信号在时钟信号上升沿后需要维持到 \(T_1\) 完全关闭以避免破坏写入的值，这一过程所需要保持的时间；\\
		\(D\)和\(C\) 传播到 \(T_1\) 的时间一般相等，因此通常原生满足保持时间约束，即 \(t_{\mrm{h}} = 0\)。
		\item \tboqi{输出响应时间} \(\mboqi{t_{\mrm{c-q}}}\)：输入信号在时钟信号上升沿后到输出信号发生变化的时间。
	\end{itemize}

	当两个 DFF 级联时：
	\begin{itemize}[leftmargin=1em]
		\item 第一个 DFF 的输入信号 \(D_1\) 在开始采样 \(t_{\mrm{c-q}}\) 时间后才会传输到其输出 \(Q_1\)，第二个 DFF 的输入信号 \(D_2\) 在开始采样前 \(t_{\mrm{su}}\) 时间内需要保持不变，因此留给中间的组合逻辑电路的时间为 \(t_{\mrm{cyc}} - t_{\mrm{c-q}} - t_{\mrm{su}}\)，逻辑计算必须在这段时间内完成，这称为\tboqi{建立时间约束}；
		\item 第一个 DFF 的输出信号 \(Q_1\) 在 \(t_{\mrm{c-q}}\) 时间后才会更新，经过组合逻辑电路后才传输到 \(D_2\)，此前 \(D_2\) 因前一次采样而需要保持不变 \(t_{\mrm{h}}\) 时间，因此组合逻辑电路的延迟时间不能小于 \(t_{\mrm{h}} - t_{\mrm{c-q}}\)，这称为\tboqi{保持时间约束}。
	\end{itemize}	
}

\subsubsection{时序逻辑电路分析}

在如图~\ref{Fig: Sequential Circuit}~所示的一般时序逻辑电路中，
有以下几个要素需要分析：
\begin{itemize}
	\item \textbf{输出方程}：根据输入信号 \(x\) 和当前状态 \(s\) 计算输出信号 \(y = f(x, s)\)；
	\item \textbf{激励方程}：根据输入信号 \(x\) 和当前状态 \(s\) 计算触发器的输入信号 \(e = g(x, s)\)；
	\item \textbf{状态转移方程（次态方程）}：根据触发输入 \(e\) 和当前状态 \(s\) 计算下一个状态 \(s^+ = h(e, s)\)；
\end{itemize}
可以通过状态转移图、状态转移表、时序图和电路行为描述等方式进行分析。

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.25]{Circuits/FIG-Sequential_Circuit.drawio.png}
	\caption{一般时序逻辑电路}
	\label{Fig: Sequential Circuit}
\end{figure}

\subsubsection{时序逻辑电路设计}

\begin{example}
	设计一个训练累计器，输入每天的跑步距离 \(Today\)，根据给定的目标跑步距离 \(Goal\) 计算剩余距离 \(Left\) 并输出。

	\begin{figure}[!ht]
		\centering
		\subfloat[]{
			\includegraphics[scale=0.25]{Circuits/FIG-Training_Accumulator_FSM1.drawio.png}
		}
		\quad
		\subfloat[]{
			\includegraphics[scale=0.25]{Circuits/FIG-Training_Accumulator_FSM2.drawio.png}
			\label{Fig: Training Accumulator FSM2}
		}
		\caption{训练累计器的FSM设计}
		\label{Fig: Training Accumulator FSM}
	\end{figure}
	\begin{table}[!ht]
		\belowrulesep=0pt
		\aboverulesep=0pt
		\caption{训练累计器的状态转移表}
		\label{Tab: Training Accumulator State Transition Table}
		\begin{tabular}{c|ccccc|c}
			\toprule
			\multirow{2}{*}{\textbf{\textit{Left}}} & \multicolumn{5}{c|}{\textbf{\textit{Today}}} & \multirow{2}{*}{\textbf{Output}} \\
			& \(0\) & \(1\) & \(\cdots\) & \(t\) & \(\cdots\) & \\
			\midrule
			1000 & 1000 & 999 & \(\cdots\) & \(1000 - t\) & \(\cdots\) & 1000 \\
			999 & 999 & 998 & \(\cdots\) & \(999 - t\) & \(\cdots\) & 999 \\
			\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) \\
			\(t\) & \(t\) & \(t - 1\) & \(\cdots\) & 0 & \(\cdots\) & \(t\) \\
			\(t - 1\) & \(t - 1\) & \(t - 2\) & \(\cdots\) & 0 & \(\cdots\) & \(t - 1\) \\
			\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) \\
			0 & 0 & 0 & \(\cdots\) & 0 & \(\cdots\) & 0 \\
			\bottomrule
		\end{tabular}
	\end{table}

	\begin{solution}
		训练累计器可以抽象成如图~\ref{Fig: Training Accumulator FSM}~所示的FSM，其中图~\ref{Fig: Training Accumulator FSM2}~显然更优。根据FSM设计，可以得到状态转移表如表~\ref{Tab: Training Accumulator State Transition Table}~所示。
	\end{solution}
\end{example}

\zhu[时序逻辑电路设计方法]{
	时序逻辑电路的设计包括以下几个步骤：
	\begin{enumerate}[leftmargin=2em, parsep=0pt, itemsep=0pt, topsep=0pt]
		\item \tboqi{抽象出一个有限状态机}，定义初始状态、输入信号、输出信号、输出函数和状态转移函数；
		\item 状态化简、合并；
		\item 状态分配；
		\item 确定激励方程和输出方程；
		\item 画出逻辑电路图。
	\end{enumerate}
}

\paragraph{寄存器}
　
\de[寄存器]{
	\tboba{寄存器（register）}是一个能够存储多个 bit 状态的电路单元，其输出信号可以保持，直到特定的输入信号触发重置或写入。仅有存储功能的寄存器称为\tboba{存储寄存器}，还带有移位功能的寄存器称为\tboba{移位寄存器}。
}

右移、左移移位寄存器可简单地通过串联多个 DFF 实现，如图~\ref{Fig: Shift Register}~所示。

\begin{figure}[!ht]
	\centering
	\subfloat[右移移位寄存器]{
		\includegraphics[scale=0.25]{Circuits/FIG-Shift_Right_Register.drawio.png}
	}
	\hskip-3em
	\subfloat[左移移位寄存器]{
		\includegraphics[scale=0.25]{Circuits/FIG-Shift_Left_Register.drawio.png}
	}
	\caption{串行移位寄存器}
	\label{Fig: Shift Register}
\end{figure}

图~\ref{Fig: Shift Register}~中的移位寄存器是\tboba{串行移位寄存器}，即每个 DFF 的输出信号与下一个 DFF 的输入信号相连，输入信号只从一个端口输入，输出信号只从一个端口输出。应当可以看出，图~\ref{Fig: Shift Register}~中的两个移位寄存器实际具有相同的逻辑电路，只是对输入信号、输出信号和各 DFF 锁存信号所赋予的意义不同。

串行输入、输出的效率较低，可以通过并行输入、输出提高效率，如图~\ref{Fig: Parallel Shift Register}~所示。

\begin{figure}[!ht]
	\centering
	\subfloat[并行输入]{
		\includegraphics[scale=0.25]{Circuits/FIG-Shift_Register_Parallel_Input.drawio.png}
	}
	\quad
	\subfloat[并行输出]{
		\includegraphics[scale=0.25]{Circuits/FIG-Shift_Register_Parallel_Output.drawio.png}
	}
	\caption{移位寄存器的并行输入、输出}
	\label{Fig: Parallel Shift Register}
\end{figure}


\paragraph{计数器}



%----------------------------------------------------------
\end{document}
