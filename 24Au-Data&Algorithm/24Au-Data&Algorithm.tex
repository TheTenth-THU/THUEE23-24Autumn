\documentclass[10pt, a4paper, oneside, fontset=none]{ctexart}

%调用宏包
\usepackage{amsmath, amsthm, amssymb, graphicx, wrapfig, mathrsfs}
\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]{hyperref}
\usepackage{color, framed, geometry, tcolorbox, nicematrix, xcolor}
\tcbuselibrary{breakable}%box跨页
\tcbuselibrary{skins}%box跨页不留边
\usepackage{makecell, booktabs, listings, float}
\usepackage[labelfont=bf, justification=raggedleft]{caption}
\usepackage{multicol}
\usepackage{extarrows}
\usepackage{enumitem}
\usepackage{yhmath}
\usepackage{multirow}
\usepackage[text=\includegraphics{C:/Users/16870/.vscode/LaTeX_Application/tex/THUEE23-23Autumn/图标简稿.png},angle=0]{draftwatermark}%水印
%\usepackage{tikz}

%基本字体设置
\catcode`\，=\active
\def ，{\textup{,}\hskip0.5em }
\usepackage[math-style=ISO, bold-style=ISO]{unicode-math}
%\newcommand{\symbf}[1]{\boldsymbol{#1}}
%\newcommand{\symup}[1]{\mathrm{#1}}
\setmonofont{Iosevka}
\newfontfamily{\mono}{Cascadia Mono Regular}
\setCJKmainfont{方正新书宋_GBK}[BoldFont={思源宋体 CN Bold}, ItalicFont={方正新楷体_GBK}, BoldItalicFont={汉仪颜楷 W}]
\setCJKsansfont{汉仪文黑-45W ExtraLight}[BoldFont={汉仪文黑-75W Bold}, ItalicFont={方正颜真卿楷书 简繁}]
\setCJKmonofont{霞鹜新晰黑}
%附加字体设置
\newCJKfontfamily{\kaico}{可口可乐在乎体 楷体}
\newCJKfontfamily{\kai}{方正新楷体_GBK}[BoldFont={汉仪颜楷 W}, ItalicFont={方正清刻本悦宋 简繁}, BoldItalicFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\yan}{方正清刻本悦宋 简繁}[ItalicFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\xiu}{方正宋刻本秀楷_GBK}[ItalicFont={方正宋刻本秀楷_GBK}, BoldFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\run}{汉仪润圆-45W ExtraLight}[BoldFont={汉仪润圆-75W Bold}, ItalicFont={汉仪润圆-45W ExtraLight}]
\newCJKfontfamily{\wen}{汉仪文黑-45W ExtraLight}[ItalicFont={汉仪文黑-75W Bold}, BoldFont={汉仪文黑-85W Heavy}, BoldItalicFont={汉仪文黑-85W Heavy}]

%文档格式
\geometry{left=1.96cm, right=1.96cm, top=3.18cm, bottom=3.18cm}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{4}
\linespread{1.4}
\renewcommand{\theparagraph}{\Alph{paragraph})}
\newcommand{\Section}[1]{ \refstepcounter{section} \section*{*\thesection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{section}{\makebox[0pt][r]{*}\thesection\texorpdfstring{\quad}{} #1} }
\newcommand{\Subsection}[1]{ \refstepcounter{subsection} \subsection*{*\thesubsection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{subsection}{\makebox[0pt][r]{*}\thesubsection\texorpdfstring{\quad}{} #1} }
\newcommand{\Subsubsection}[1]{ \refstepcounter{subsubsection} \subsubsection*{*\thesubsubsection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{subsubsection}{\makebox[0pt][r]{*}\thesubsubsection\texorpdfstring{\quad}{} #1} }
\setlist[itemize]{leftmargin=3em, labelsep=0.25em, itemindent=0em, itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt}
\setlength{\lineskip}{5pt}
\setlength{\lineskiplimit}{5pt}
\setlength{\belowcaptionskip}{-1em}
\setlength{\abovecaptionskip}{0.5em}
\setlength{\columnsep}{1cm} % 分栏间距
\setlength{\columnseprule}{.4pt} % 栏分割线粗
\setlength{\abovecaptionskip}{0.2em}
\setlength{\belowcaptionskip}{-0.5em}
\def\columnseprulecolor{\color{white!50!black}}

%定理环境
\theoremstyle{plain}
\newtheorem{theorem}{定理}[subsection]
\newtheorem{definition}{定义}[section]
\newtheorem{lemma}[theorem]{引理}
\newtheorem{corollary}[theorem]{推论}
\newtheorem{proposition}[theorem]{命题}

\theoremstyle{definition}
\newtheorem{example}[theorem]{例}
\newtheorem{circum}[theorem]{情形}

\newenvironment{proofs}[1][\small\proofname]{\begin{pf}[breakable, enhanced jigsaw]\begin{proof}[#1]\small\kai}{\end{proof}\end{pf}}
%\newenvironment{solution}{\begin{proofs}[\small\textit{\yan 解}]\small\renewcommand{\qedsymbol}{$\circledS$}}{\end{proofs}}
\renewcommand{\proofname}{\yan{证明}}

\newenvironment{twoc}{\vspace{-11pt}\begin{multicols}{2}}{\end{multicols}\vspace{-9pt}}
%颜色命名
\definecolor{meihong}{rgb}{0.85,0.2,0.47}
\definecolor{bali}{rgb}{0.2,0.6,0.78}
\definecolor{qinglv}{rgb}{0,0.35,0.32}
\newcommand{\colors}[1]{\color{#1!75!black}}
%tbox环境
\newtcolorbox{pr}[2][]{colback=black!5!white,colframe=white!75!black,fonttitle=\sffamily\wen\bfseries,title=#2,#1}
\newtcolorbox[use counter=definition,number within=subsection]{defi}[2][]{colback=bali!5!white,colframe=bali!75!black,fonttitle=\sffamily\wen\bfseries,title=定义~\thetcbcounter. #2,#1}
\newtcolorbox[auto counter,number within=section]{compl}[2][]{colback=bali!5!white,colframe=bali!65!black,fonttitle=\sffamily\wen\bfseries,label=#2,title=电路部件~\thetcbcounter. #2,#1, fontupper=\kai, fontlower=\kai}
\newcounter{algo}[section]
\newtcolorbox[use counter=algo,number within=section]{theo}[2][]{colback=meihong!5!white,colframe=meihong!75!black,fonttitle=\sffamily\wen\bfseries,fontupper=\run,title=算法~\thetcbcounter. #2,#1}
\newtcolorbox[use counter=definition,number within=subsection]{defil}[2][]{colback=bali!5!white,colframe=bali!75!black,fonttitle=\sffamily\wen\bfseries,label=#2,title=定义~\thetcbcounter. #2,#1}
\newtcolorbox[use counter=algo,number within=section]{theol}[2][]{colback=meihong!5!white,colframe=meihong!75!black,fonttitle=\sffamily\wen\bfseries,fontupper=\run,label=#2,title=算法~\thetcbcounter. #2,#1}
\newtcolorbox[auto counter,number within=section]{note}[2][]{colback=qinglv!5!white,colframe=qinglv!75!black,breakable, enhanced jigsaw,fonttitle=\sffamily\wen\bfseries,title=注~\thetcbcounter. #2,#1}
\newtcolorbox{prenote}[2][]{colback=gray!5!white,colframe=gray!50!black,breakable, enhanced jigsaw, fonttitle=\sffamily\wen\bfseries,fontupper=\small\kai,title=#2,#1}
\newtcolorbox{pf}[1][]{colback=black!5!white,colframe=white!75!black, fontupper=\small\kai,#1}
%\newcommand{\mybox}[1]{\tikz[baseline=(MeNode.base)]{\node[rounded corners, fill=gray!20](MeNode){#1};}}

%代码环境
\lstset{
	xleftmargin=3em, xrightmargin=1em, 
	breaklines,                                 % 自动将长的代码行换行排版
	extendedchars=false,                        % 解决代码跨页时，章节标题，页眉等汉字不显示的问题
	rulecolor=\color[rgb]{0.8,0.8,0.8},         % 设置代码框颜色
	backgroundcolor=\color[rgb]{0.96,0.96,0.96},% 背景颜色
	keywordstyle=\colors{bali}\bfseries,        % 关键字颜色
	keywordstyle=[2]\color{qinglv}\bfseries,   % 自定义关键字颜色
	keywordstyle=[3]\color{purple!70!black}\ttfamily,	% 自定义关键字颜色
	identifierstyle=\color{black},              % 普通标识符颜色
	commentstyle=\rm\kai\color{gray},          	% 注释颜色
	stringstyle=\colors{meihong},      			% 字符串颜色
	showstringspaces=false,                     % 不显示字符串内的空格
	numbers=left,                               % 显示行号
	stepnumber=1,                               % 设置行号递增间隔
	numberstyle=\tiny\ttfamily,              			% 设置数字字体
	basicstyle=\linespread{1}\tt,               % 设置基本字体
	captionpos=t,                               % title在上方(在bottom即为b)
	frame=single,                               % 设置代码框形式
	showtabs=false, 
	numbersep=15pt, 
	framesep=1em, 
	language=C++, 
	columns=fixed,
	basewidth=0.5em, 
	tabsize=4, 
	gobble=4,
	escapeinside={(*@}{@*)},
}
\lstdefinestyle{intro}
	{rulecolor=\color{bali!75!black}, backgroundcolor=\color{bali!5!white}, keywordstyle=\color{bali!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{bali}]{<-}{->}, escapeinside={(*@}{@*)}, }
\lstdefinestyle{algo}
	{rulecolor=\color{meihong!75!black}, backgroundcolor=\color{meihong!5!white}, keywordstyle=\color{meihong!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{bali}]{<-}{->}, escapeinside={(*@}{@*)}, }
\lstdefinestyle{qintro}
	{rulecolor=\color{bali!75!black}, backgroundcolor=\color{bali!5!white}, keywordstyle=\color{qinglv!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{qinglv}]{<-}{->}, escapeinside={(*@}{@*)}, }
\lstdefinestyle{notec}
	{xleftmargin=3.5em, xrightmargin=2.5em, rulecolor=\color{qinglv!75!black}, backgroundcolor=\color{qinglv!5!white}, keywordstyle=\color{qinglv!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{qinglv}]{<-}{->}, escapeinside={(*@}{@*)}, }
\lstdefinestyle{output}
	{rulecolor=\color{white!75!black}, backgroundcolor=\color{white!5!black}, language={}, basicstyle=\linespread{1}\color{white!90!black}\mono\wen, identifierstyle=\linespread{1}\color{white!90!black}\mono, morecomment=[s][\it]{<-}{->}, showspaces=false, basewidth=0.6em, escapeinside={(*@}{@*)}}

%定义格式记号
\newcommand{\hang}[1][1]{\hangafter 1 \hangindent #1em}
\newcommand{\den}[2][]{\begin{defi}{#1}\kai #2\end{defi}}
\newcommand{\din}[2][]{\begin{theo}{#1}\run #2\end{theo}}
\newcommand{\de}[2][]{\begin{defil}{#1}\kai #2\end{defil}}
\newcommand{\di}[3][]{\begin{theol}{#1}\run \textbf{\wen 思想\hskip0.65em}#2 \tcblower\run \hang[3]\textbf{\wen 步骤\quad}\hskip-0.65em#3 \end{theol}}
\newcommand{\dep}[3][]{\begin{defi}{#1\page{#2}}\kai #3\end{defi}}
\newcommand{\dip}[3][]{\begin{theo}{#1\page{#2}}\run #3\end{theo}}
\newcommand{\zhu}[2][]{\begin{note}{#1}\xiu #2\end{note}}
\newcommand{\tboba}[1]{\textbf{\kai\color{bali!75!black}#1}}
\newcommand{\mboba}[1]{\kai\symbf{\color{bali!75!black}#1}}
\newcommand{\tbome}[1]{\textbf{\run\color{meihong!75!black}#1}}
\newcommand{\mbome}[1]{\run\symbf{\color{meihong!75!black}#1}}
\newcommand{\tboqi}[1]{\textbf{\xiu\color{qinglv!75!black}#1}}
\newcommand{\mboqi}[1]{\xiu\symbf{\color{qinglv!75!black}#1}}
\NewTotalTCBox{\code}{ O{red} v !O{} }{
	fontupper=\mono, nobeforeafter, tcbox raise base, arc=0pt, outer arc=0pt, top=1pt, bottom=1pt, left=1pt, right=1pt, leftrule=0pt, rightrule=0pt, toprule=0.3mm, bottomrule=0.3mm, boxsep=0.5mm, colback=#1!10!white, colframe=#1!50!black, #3
}{#2}

%定义算符
\def\upint{\mathchoice%
	{\mkern13mu\overline{\vphantom{\intop}\mkern7mu}\mkern-20mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
  \int}
\def\lowint{\mkern3mu\underline{\vphantom{\intop}\mkern7mu}\mkern-10mu\int}
\newcommand*{\dif}{\mathop{}\!\symrm{d}}
\newcommand*{\e}{\symrm{e}}
\renewcommand{\i}{\symrm{i}}
\newcommand*{\R}{\mathbb{R}}
\newcommand{\dint}[1][]{\displaystyle{\int #1}}
\renewcommand{\a}[1]{\left\langle #1 \right\rangle}
\newcommand*{\page}[1]{\hfill P$_\text{#1}$}

%标题、作者、日期
\title
{
	\textbf{数据与算法}{\kai 知识与方法}
}
\author{\zihao{5} T$^\text{T}$T}
\date{\zihao{5}\kai \today}
%----------------------------------------------------------
\begin{document}

\maketitle
\begin{multicols}{2}
	\begin{flushleft}
		\tableofcontents
	\end{flushleft}
\end{multicols}

\newpage
%----------------------------------------------------------
\setcounter{section}{-1}
\section{绪论：数据、数学模型、算法}

\subsection{数据及其结构}

\begin{definition}
	数据的基本单元称为\tboba{数据元素}。
\end{definition}

数据元素并不是孤立存在的，而是存在密切的联系。

数据的逻辑结构：
\begin{itemize}
	\item \tboba{集合结构}：数据元素之间没有任何关系
	\item \tboba{线性结构}：数据元素之间存在一对一的关系，如线性表、栈、队列、串
	\item \tboba{树形结构}：数据元素之间存在一对多的关系，如树
	\item \tboba{图形结构}：数据元素之间存在多对多的关系，如图
\end{itemize}

数据的存储结构：
\begin{itemize}
	\item \tboba{顺序存储结构}：将数据元素存放在地址连续的存储单元里
	\item \tboba{链式存储结构}：将数据元素存放在任意的存储单元里，通过指针相连
\end{itemize}

\subsection{数学模型}

\begin{definition}
	\tboba{数学模型}是对于现实世界的某一特定对象，根据其内在规律，为特定目的而得到的一个抽象的、简化的数学结构。
\end{definition}

常用的数学模型的类型：
\begin{itemize}
	\item \tboba{线性方程组}：超定线性方程组的线性拟合、欠定线性方程组的线性规划
	\item \tboba{非线性方程组}：非线性方程组的求解
	\item \tboba{微分方程}：常微分方程的数值解法、偏微分方程的数值解法
	\item \tboba{概率模型}：概率预测、概率统计
	\item \tboba{统计模型}：统计预测、统计分析
	\item \tboba{离散模型}：线性结构、树结构、图结构
	\item \tboba{优化模型}：线性规划、整数规划、非线性规划
\end{itemize}

\subsection{算法}

\begin{definition}
	\tboba{算法}是用以解决某一问题的有限长度的指令序列。
\end{definition}

算法的基本特点：
\begin{itemize}
	\item \tboba{有穷性}：算法必须在执行有穷步之后能够结束，且每一步都可在有穷时间内完成
	\item \tboba{确定性}：算法的每一步必须有确切的含义，算法的实际执行结果是确定的、且精确地符合要求或期望
	\item \tboba{可行性}：算法中描述的操作都可以通过已经实现的基本操作运算的有限次执行来实现
	\item \tboba{输入}：算法必须有零个或多个输入
	\item \tboba{输出}：算法必须有一个或多个输出
\end{itemize}

好的算法应该具有以下特点：
\begin{itemize}
	\item \tboba{正确性}：算法应该能够解决问题
	\begin{itemize}
		\item 不含语法错误
		\item 对一般的输入数据能够产生正确的输出结果
		\item 对精心选择的苛刻数据也能产生正确的输出结果
		\item 对于所有的输入数据都能产生正确的输出结果
	\end{itemize}
	\item \tboba{可读性}：算法应该容易理解
	\item \tboba{健壮性}：算法应该能够处理各种异常情况
	\item \tboba{高效性}：算法应该能够在合理的时间和空间开销内解决问题
\end{itemize}

一个特定算法的运行工作量的大小，与问题规模的大小有关，这种关系称为算法的复杂度。

\de[渐进时间复杂度]{
	算法的\tboba{（渐进）时间复杂度}是指算法的运行时间与问题规模之间的关系。
}

\begin{example}
	现有程序如下：
	\begin{lstlisting}[gobble=8]
		for(int i = 0; i < n; i++)
			for(int j = i; j < n; j++)
				if(a[i] > a[j])
					swap(a[i], a[j]);
	\end{lstlisting}
	其中，基本操作\,\lstinline|swap|\,函数的时间复杂度为\(O(1)\)，
	其执行次数为\(\sum\limits_{i=0}^{n-1}\sum\limits_{j=i}^{n-1}1 = \sum\limits_{i=0}^{n-1}(n-i) = \sum\limits_{i=0}^{n-1}i = \dfrac{n(n-1)}{2}\)，
	则该程序的时间复杂度为\(O\left(\dfrac{n(n-1)}{2}\right) = O(n^2)\)。
\end{example}

\begin{example}
	现有程序如下：
	\begin{lstlisting}[gobble=8]
		for(int i = 1; i < n; i++)
			for(int j = 0; j < i; j *= 2)
				a[i] += a[j];
	\end{lstlisting}
	其内层循环的时间复杂度为\(O(\log_2i)\)，
	则该程序的时间复杂度为
	\begin{align*}
		\sum\limits_{i=2}^{n-1} O(\log_2i) &= O\left(\sum\limits_{i=2}^{n-1} \log_2i\right)
		= O\left(\log_2\left(\prod\limits_{i=2}^{n-1} i\right)\right) \\
		&= O\left(\log_2(n-1)!\right) = O\left(\log_2n!\right) = O(n\log_2n)
	\end{align*}
\end{example}

\de[渐进空间复杂度]{
	算法的\tboba{（渐进）空间复杂度}是指算法的空间开销与问题规模之间的关系。
}

\section{数据结构}

\subsection{抽象数据类型}

\de[数据类型]{
	\tboba{数据类型}是元素的集合 \(D\)、集合中元素的关系 \(R\) 和定义在此集合上的对这些元素的操作的集合 \(C\) 的总称。
}

数据类型是一种封装好的数据结构，把用户无须了解的实现细节封装起来，只提供刻画外在特性的接口。对于高级语言，除开语言本身定义好的\textbf{原子类型}外，用户还可以自定义\textbf{结构类型}，即\textbf{抽象数据类型（ADT）}。

\begin{example}
	复数的抽象数据类型定义如下：
	\begin{lstlisting}[gobble=8, morekeywords={ADT, }, morekeywords={[2]{Complex, }}, morekeywords={[3]{InitComplex, DestroyComplex, Add, Sub, }}]
		ADT Complex {
			数据对象：(*@\(D = \{ e_1，e_2 \mid e_1，e_2 \in \R \}\)@*)
			数据关系：(*@\(R = \{ \a{e_1，e_2} \mid e_1 = \mathfrak{Re}(D)，e_2 = \mathfrak{Im}(D)\}\)@*)
			基本操作：
				InitComplex(&Z, v1, v2)
					操作结果：构造复数 Z, 其实部和虚部分别被赋以参数 v1 和 v2 的值。
				DestroyComplex(&Z)
					初始条件：复数 Z 存在；
					操作结果：复数 Z 被销毁。
				Add(z1, z2, &sum)
					初始条件：z1, z2 是复数。
					操作结果：用 sum 返回两个复数 z1, z2 的和值。
				Sub(z1, z2, &sub)
					初始条件：z1, z2 是复数。
					操作结果：用 sub 返回两个复数 z1, z2 的差值。
		} ADT Complex
	\end{lstlisting}
\end{example}

\begin{example}
	圆柱体的抽象数据类型定义如下：
	\begin{lstlisting}[gobble=8, morekeywords={ADT, }, morekeywords={[2]{CYLinder, }}, morekeywords={[3]{InitCyld, BaseArea, SideArea, Volume, }}]
		ADT CYLinder {
			数据对象：(*@\( D = \{r，h \mid r，h \in \R \} \)@*)
			数据关系：(*@\( R = \{\a{r，h} \mid r\text{ 为圆柱底面半径}，h\text{ 为圆柱高}\} \)@*)
			基本操作：
				InitCyld(r, h)
					操作结果：构造圆柱体, 底面半径 r, 圆柱高 h。
				BaseArea(r, &bArea)
					初始条件：圆柱体存在。
					操作结果：计算圆柱体底面积, 用 bArea 返回。
				SideArea(r, h, &sArea)
					初始条件：圆柱体存在。
					操作结果：计算圆柱体侧面积, 用 sArea 返回。
				Volume(r, h, &vol)
					初始条件：圆柱体存在。
					操作结果：计算圆柱体体积, 用 vol 返回。
		} ADT CYLinder
	\end{lstlisting}
\end{example}

\subsection{线性结构}

\subsubsection{线性表}

\de[线性表]{
	\tboba{线性表}是一种「有序」结构，即在数据元素的非空有限集合中，
	\begin{itemize}
		\item 存在唯一的一个被称为「\tboba{第一个}」的数据元素，无前驱；
		\item 存在唯一的一个被称为「\tboba{最后一个}」的数据元素，无后继；
		\item 除第一个之外，每个数据元素均只有一个直接\tboba{前驱}；
		\item 除最后一个之外，每个数据元素均只有一个直接\tboba{后继}。
	\end{itemize}
	对呈现这样结构的数据，可以记为 \(L = (a_0，a_1，a_2，\cdots，a_{i-1}，a_i，a_{i+1}，\cdots，a_n)\)，并称
	\begin{itemize}
		\item \(a_i\) 为\tboba{第 i 个}数据元素，\(i\) 为数据元素 \(a_i\) 的\tboba{位序}；
		\item \(a_{i-1}\) 为 \(a_i\) 的\tboba{直接前驱}；
		\item \(a_{i+1}\) 为 \(a_i\) 的\tboba{直接后继}；
		\item \(n + 1\) ，即线性表中数据元素的个数，为表的\tboba{长度}。
	\end{itemize}
}

线性表的抽象数据类型可以定义为：
\begin{lstlisting}[style=intro, morekeywords={ADT, }, morekeywords={[2]{List, ElemType, compare, visit, }}, morekeywords={[3]{InitList, DestroyList, IsEmpty, ListLength, GetElem, LocateElem, PriorElem, NextElem, ClearList, ListInsert, ListDelete, ListTraverse, }}]
	ADT List {
		数据对象：(*@\( D = \{a_0，a_1，a_2，\cdots，a_n \mid a_i \in \text{ElemType}，1 \leq i \leq n \} \)@*)
		数据关系：(*@\( R = \{ \a{a_i，a_{i+1}} \mid a_i \text{为第} \, i \,  \text{个数据元素，} a_{i+1} \text{为第}\, i+1 \, \text{个数据元素} \} \)@*)
		基本操作：
			InitList(&L)
				操作结果：构造一个空的线性表 L。
			DestroyList(&L)
				初始条件：线性表 L 存在。
				操作结果：销毁线性表 L。
			IsEmpty(L)
				初始条件：线性表 L 存在。
				操作结果：若 L 为空表, 则返回 true, 否则返回 false。
			ListLength(L)
				初始条件：线性表 L 存在。
				操作结果：返回 L 中数据元素的个数。
			GetElem(L, i, &e)
				初始条件：线性表 L 存在, 0 <= i < ListLength(L)。
				操作结果：用 e 返回 L 中第 i 个数据元素的值。
			LocateElem(L, e, compare())
				初始条件：线性表 L 存在, compare() 是数据元素判定函数。
				操作结果：返回 L 中第一个与 e 满足 compare() 的数据元素的位序；若不存在, 则返回 -1。
			PriorElem(L, cur_e, &pre_e)
				初始条件：线性表 L 存在。
				操作结果：若 cur_e 是 L 的数据元素, 且不是第一个, 则用 pre_e 返回它的直接前驱；否则操作失败。
			NextElem(L, cur_e, &next_e)
				初始条件：线性表 L 存在。
				操作结果：若 cur_e 是 L 的数据元素, 且不是最后一个, 则用 next_e 返回它的直接后继；否则操作失败。
			ClearList(&L)
				初始条件：线性表 L 存在。
				操作结果：将 L 重置为空表。
			ListInsert(&L, i, e)
				初始条件：线性表 L 存在, 0 <= i <= ListLength(L)。
				操作结果：在 L 的第 i 个位置（第 i 个元素之前）插入新的数据元素 e, L 的长度加 1。
			ListDelete(&L, i, &e)
				初始条件：线性表 L 存在, 0 <= i < ListLength(L)。
				操作结果：删除 L 的第 i 个数据元素, 并用 e 返回其值, L 的长度减 1。
			ListTraverse(L, visit())
				初始条件：线性表 L 存在, visit() 是对数据元素操作的函数。
				操作结果：依次对 L 的每个数据元素调用 visit(), 一旦 visit() 失败, 则操作失败。
	} ADT List
\end{lstlisting}

\paragraph{线性表的实现}

按照存储结构的不同，线性表可以分为顺序表和链表。

\begin{itemize}
	\item \textbf{顺序表}：线性表的存储结构为顺序存储结构，即用一组地址连续的存储单元依次存放线性表中的元素。
	
	可以用 C++ 语言实现一个顺序表：
	\begin{lstlisting}[style=intro, morekeywords={[2]{List, ElemType, }}, morekeywords={[3]{isEmpty, listLength, getElem, locateElem, priorElem, nextElem, clearList, listInsert, listDelete, listTraverse, visit, }}, gobble=8]
		class List {
		private:
			ElemType *elem;
			int length, maxSize;
		public:
			List(int size) : maxSize(size) 
				{ elem = new ElemType[maxSize]; length = 0; }
			~List() 						{ delete[] elem; }
			bool isEmpty() const 			{ return length == 0; }
			int listLength() const 			{ return length; }
			ElemType getElem(int i) const 	{ return elem[i]; }
			int locateElem(ElemType e) const {
				for (int i = 0; i < length; i++)
					if (elem[i] == e) return i;
				return -1;
			}
			ElemType priorElem(ElemType e) const {
				int i = locateElem(e);
				if (i > 0) return elem[i - 1];
				return -1;
			}
			ElemType nextElem(ElemType e) const {
				int i = locateElem(e);
				if (i >= 0 && i < length - 1) return elem[i + 1];
				return -1;
			}
			void clearList() 				{ length = 0; }
			bool listInsert(int i, ElemType e) {
				if (i < 0 || i > length || length == maxSize) return false;
				for (int j = length; j > i; j--)
					elem[j] = elem[j - 1];
				elem[i] = e; 
				length++;
				return true;
			}
			ElemType listDelete(int i) {
				if (i < 0 || i >= length) return -1;
				ElemType e = elem[i];
				for (int j = i; j < length - 1; j++)
					elem[j] = elem[j + 1];
				length--; return e;
			}
			void listTraverse(void (*visit)(ElemType)) const {
				for (int i = 0; i < length; i++)
					visit(elem[i]);
			}
		};
	\end{lstlisting}
\end{itemize}

\subsubsection{栈}

\de[栈]{
	\tboba{栈}是一种特殊的线性表，其插入和删除操作只能在表的同一端进行，这一端被称为\tboba{栈顶}，另一端被称为\tboba{栈底}。
}

栈的抽象数据类型可以定义为：
\begin{lstlisting}[style=intro, morekeywords={ADT, }, morekeywords={[2]{Stack, ElemType, visit, }}, morekeywords={[3]{InitStack, DestroyStack, IsEmpty, GetTop, Push, Pop, ClearStack, StackLength, }}]
	ADT Stack {
		数据对象：(*@\( D = \{a_0，a_1，a_2，\cdots，a_n \mid a_i \in \text{ElemType}，1 \leq i \leq n \} \)@*)
		数据关系：(*@\( R = \{ \a{a_i，a_{i+1}} \mid a_i \text{为第} \, i \,  \text{个数据元素，} a_{i+1} \text{为第}\, i+1 \, \text{个数据元素} \} \)@*)
		基本操作：
			InitStack(&S)
				操作结果：构造一个空栈 S。
			DestroyStack(&S)
				初始条件：栈 S 存在。
				操作结果：销毁栈 S。
			IsEmpty(S)
				初始条件：栈 S 存在。
				操作结果：若 S 为空栈, 则返回 true, 否则返回 false。
			GetTop(S, &e)
				初始条件：栈 S 存在, S 非空。
				操作结果：用 e 返回 S 的栈顶元素。
			Push(&S, e)
				初始条件：栈 S 存在。
				操作结果：将元素 e 压入栈顶。
			Pop(&S, &e)
				初始条件：栈 S 存在, S 非空。
				操作结果：弹出栈顶元素，并用 e 返回其值。
			ClearStack(&S)
				初始条件：栈 S 存在。
				操作结果：将 S 重置为空栈。
			StackLength(S)
				初始条件：栈 S 存在。
				操作结果：返回 S 的元素个数。
	} ADT Stack
\end{lstlisting}

\paragraph{栈的实现}

按照存储结构的不同，栈可以分为顺序栈和链式栈。

\begin{itemize}
	\item \textbf{顺序栈}：栈的存储结构为顺序存储结构，即用一组地址连续的存储单元依次存放栈中的元素。
	
	可以用 C++ 语言实现一个顺序栈：
	\begin{lstlisting}[style=intro, morekeywords={ElemType, }, morekeywords={[2]{Stack, }}, morekeywords={[3]{isEmpty, getTop, stackLength, push, pop, clearStack, }}, gobble=8]
		class Stack {
		private:
			ElemType *bottom;
			int stackDepth, maxSize;
		public:
			Stack(int size) : maxSize(size) 
				{ bottom = new ElemType[maxSize]; stackDepth = 0; }
			~Stack() 						{ delete[] bottom; }
			bool isEmpty() const 			{ return stackDepth == 0; }
			ElemType getTop() const 		{ return bottom[stackDepth - 1]; }
			int stackLength() const 		{ return stackDepth; }
			void push(ElemType e) 			{ bottom[stackDepth++] = e; }
			ElemType pop() 					{ return bottom[--stackDepth]; }
			void clearStack() 				{ stackDepth = 0; }
		};		
	\end{lstlisting}
	在初始化顺序栈时，需要指定栈的最大容量 \lstinline|maxSize|，如果栈中元素已经达到最大容量，继续压栈会导致\tboba{栈溢出}。在具体实现中，根据需要可以具体设计如何处理栈溢出的情况。

	\item \textbf{链式栈}：栈的存储结构为链式存储结构，即用链表存放栈中的元素。
	
	可以用 C++ 语言实现一个链式栈：
	\begin{lstlisting}[style=intro, morekeywords={ElemType, }, morekeywords={[2]{Stack, Node, Link, }}, morekeywords={[3]{isEmpty, getTop, stackLength, push, pop, clearStack, }}, gobble=8]
		struct Node {
			ElemType data;
			Node *next;
		};
		typedef struct Node* Link;
		class Stack {
		private:
			Link head;
		public:
			Stack() 				{ head = nullptr; }
			~Stack() 				{ clearStack(); }
			bool isEmpty() const 	{ return head == nullptr; }
			ElemType getTop() const { return head->data; }
			int stackLength() const 
				{ int len = 0; for (Link p = head; p; p = p->next) len++; return len; }
			void push(ElemType e) 
				{ Link p = new Node; p->data = e; p->next = head; head = p; }
			ElemType pop() 
				{ Link p = head; head = head->next; ElemType e = p->data; delete p; return e; }
			void clearStack() 		{ while (!isEmpty()) pop(); }
		};
	\end{lstlisting}
	链式栈的实现中，栈顶元素位于链表的头部，每次压栈时，新元素插入到链表的头部；每次弹栈时，栈顶元素从链表的头部删除。
\end{itemize}

\begin{example}
	\textbf{后缀表达式}是一种不含括号的表达式，其操作符位于操作数后面。例如，后缀表达式 \(3\,4\,+\,5\,*\) 对应的中缀表达式为 \((3 + 4) * 5\)。在计算机处理中，后缀表达式的计算更加方便。用栈实现四则运算后缀表达式的计算如下：
	\begin{lstlisting}[morekeywords={ValueException, }, morekeywords={[2]{Stack, }}, morekeywords={[3]{calcPostfix, isEmpty, push, pop, }}, gobble=8]
		double calcPostfix(const char *postfix) {
			strstream ss(postfix);					// 用字符串流读取后缀表达式
			Stack values;
			int curValue = 0; char curChar = '\0';
			while (ss >> curChar) {					// 逐个读取字符
				if (isdigit(curChar)) {				// 对数字字符，转换为数字并入记录数值
					curValue = curValue * 10 + curChar - '0';
				} else {							// 对操作符，弹栈计算
					int preValue = values.pop();
					switch (curChar) {
					case '+': values.push(preValue + curValue); break;
					case '-': values.push(preValue - curValue); break;
					case '*': values.push(preValue * curValue); break;
					case '/': values.push(preValue / curValue); break;
					}
					curValue = 0;					// 重置记录数值
				}
			}
			if (values.stackLength() != 1) throw ValueException("Invalid postfix expression!");
			return values.pop();
		}
	\end{lstlisting}					
\end{example}

\paragraph{栈与递归}

递归是一种常见的算法设计方法，递归函数的调用过程可以看作是一个栈的过程。递归函数的调用过程中，每次调用函数时，都会将当前函数的局部变量、返回地址等信息压入栈中，当递归函数返回时，会将这些信息弹出。

\begin{example}
	\label{e.g: Fibonacci recursion}
	计算斐波那契数列的第 \(n\) 项的递归函数如下：
	\begin{lstlisting}[morekeywords={[3]{fibonacci, }}, gobble=8]
		int fibonacci(int n) {
			if (n == 0) return 1;
			if (n == 1) return 1;
			return fibonacci(n - 1) + fibonacci(n - 2);
		}
	\end{lstlisting}
	在计算斐波那契数列的第 \(n\) 项时，递归函数 \lstinline|fibonacci| 会不断调用自身，直到递归到 \lstinline|n = 0| 或 \lstinline|n = 1| 时返回，这个过程可以看作是一个栈的过程。
\end{example}

递归算法可能导致较高的时间复杂度和空间复杂度，因此有时需要考虑使用非递归的方法来实现，即\textbf{递归的消除}。以下两类递归函数可以比较容易地消除：
\begin{itemize}
	\item \textbf{尾递归}：如果一个递归函数中只有唯一一个递归调用语句，并且递归调用语句在递归算法的最后，称为尾递归。尾递归可以通过循环来实现，从而避免栈的过多压入和弹出。
	\item \textbf{单向递归}：如果一个递归函数中虽然有多处递归调用语句，但各递归调用语句的参数之间无关，并且递归调用语句都在递归算法的最后。单向递归可以通过设置变量保存中间结果，从而用循环结构代替递归。
\end{itemize}

\begin{example}
	例 \ref{e.g: Fibonacci recursion} 中的斐波那契数列的递归函数是一个单向递归函数，消除递归的算法设计为：
	\begin{lstlisting}[morekeywords={[3]{fibonacci, }}, gobble=8]
		int fibonacci(int n) {
			if (n == 0) return 1;
			if (n == 1) return 1;
			int pre = 0, cur = 1, next;
			for (int i = 2; i <= n; i++) {
				next = pre + cur;
				pre = cur; cur = next;
			}
			return next;
		}
	\end{lstlisting}
\end{example}

\subsubsection{队列}

\de[队列]{
	\tboba{队列}是一种特殊的线性表，其插入操作只能在表的一端进行，这一端被称为\tboba{队头}；删除操作只能在表的另一端进行，称为\tboba{队尾}。
}

队列的抽象数据类型可以定义为：
\begin{lstlisting}[style=intro, morekeywords={ADT, }, morekeywords={[2]{Queue, ElemType, }}, morekeywords={[3]{InitQueue, DestroyQueue, IsEmpty, QueueLength, GetHead, EnQueue, DeQueue, ClearQueue, QueueTraverse, visit, }}]
	ADT Queue {
		数据对象：(*@\( D = \{a_0，a_1，a_2，\cdots，a_n \mid a_i \in \text{ElemType}，1 \leq i \leq n \} \)@*)
		数据关系：(*@\( R = \{ \a{a_i，a_{i+1}} \mid a_i \text{为第} \, i \,  \text{个数据元素，} a_{i+1} \text{为第}\, i+1 \, \text{个数据元素} \} \)@*)
				  约定：队头为 a_0，队尾为 a_n。
		基本操作：
			InitQueue(&Q)
				操作结果：构造一个空队列 Q。
			DestroyQueue(&Q)
				初始条件：队列 Q 存在。
				操作结果：销毁队列 Q。
			IsEmpty(Q)
				初始条件：队列 Q 存在。
				操作结果：若 Q 为空队列, 则返回 true, 否则返回 false。
			QueueLength(Q)
				初始条件：队列 Q 存在。
				操作结果：返回 Q 的元素个数。
			GetHead(Q, &e)
				初始条件：队列 Q 存在, Q 非空。
				操作结果：用 e 返回 Q 的队头元素。
			EnQueue(&Q, e)
				初始条件：队列 Q 存在。
				操作结果：将元素 e 入队列 Q 的队尾。
			DeQueue(&Q, &e)
				初始条件：队列 Q 存在, Q 非空。
				操作结果：将 Q 的队头元素出队列，并用 e 返回其值。
			ClearQueue(&Q)
				初始条件：队列 Q 存在。
				操作结果：将 Q 重置为空队列。
			QueueTraverse(Q, visit())
				初始条件：队列 Q 存在, visit() 是对数据元素操作的函数。
				操作结果：依次对 Q 的每个数据元素调用 visit(), 一旦 visit() 失败, 则操作失败。
	} ADT Queue
\end{lstlisting}

\paragraph{队列的实现}

按照存储结构的不同，队列可以分为顺序队列和链式队列。

\begin{itemize}
	\item \textbf{顺序队列}：队列的存储结构为顺序存储结构，即用一组地址连续的存储单元依次存放队列中的元素。为了避免队列整体移动，通常采用\textbf{循环队列}的方式实现顺序队列。
	
	可以用 C++ 语言实现一个顺序队列：
	\begin{lstlisting}[style=intro, morekeywords={ElemType, }, morekeywords={[2]{Queue, }}, morekeywords={[3]{isEmpty, getHead, queueLength, enQueue, deQueue, clearQueue, }}, gobble=8]
		class Queue {
		private:
			ElemType *base;
			int front, rear, maxSize;
		public:
			Queue(int size) : maxSize(size) 
				{ base = new ElemType[maxSize]; front = rear = 0; }
			~Queue() 						{ delete[] base; }
			bool isEmpty() const 			{ return front == rear; }
			ElemType getHead() const 		{ return base[front]; }
			int queueLength() const 		{ return (rear - front + maxSize) % maxSize; }
			void enQueue(ElemType e)
				{ base[rear] = e; rear = (rear + 1) % maxSize; }
			ElemType deQueue()
				{ ElemType e = base[front]; front = (front + 1) % maxSize; return e; }
			void clearQueue() 				{ front = rear = 0; }
		};
	\end{lstlisting}

	\item \textbf{链式队列}：队列的存储结构为链式存储结构，即用链表存放队列中的元素。链式队列是只在头尾两端进行插入和删除操作的更简单的链表。
	
	可以用 C++ 语言实现一个链式队列：
	\begin{lstlisting}[style=intro, morekeywords={ElemType, }, morekeywords={[2]{Queue, Node, Link, }}, morekeywords={[3]{isEmpty, getHead, queueLength, enQueue, deQueue, clearQueue, }}, gobble=8]
		struct Node {
			ElemType data;
			Node *next;
		};
		typedef struct Node* Link;
		class Queue {
		private:
			Link front, rear;
		public:
			Queue() 						{ front = rear = new Node; front->next = nullptr; }
			~Queue() 						{ clearQueue(); delete front; }
			bool isEmpty() const 			{ return front == rear; }
			ElemType getHead() const 		{ return front->next->data; }
			int queueLength() const 
				{ int len = 0; for (Link p = front->next; p; p = p->next) len++; return len; }
			void enQueue(ElemType e) 
				{ Link p = new Node; p->data = e; p->next = nullptr; rear->next = p; rear = p; }
			ElemType deQueue() 
				{ Link p = front->next; front->next = p->next; ElemType e = p->data; delete p; return e; }
			void clearQueue() 				{ while (!isEmpty()) deQueue(); }
		};
	\end{lstlisting}
\end{itemize}

\paragraph{优先级队列}

给队列中的每一个元素都赋予一个优先级，优先级高的元素先出队列，这种队列称为\textbf{优先级队列}。

优先级队列的抽象数据类型可以定义为：
\begin{lstlisting}[style=intro, morekeywords={ADT, }, morekeywords={[2]{PQueue, ElemType, }}, morekeywords={[3]{InitPQueue, DestroyPQueue, IsEmpty, PQueueLength, GetHead, EnPQueue, DePQueue, ClearPQueue, PQueueTraverse, visit, }}]
	ADT PQueue {
		数据对象：(*@\( D = \{a_0，a_1，a_2，\cdots，a_n \mid a_i \in \)@*) map<int, ElemType>(*@，\(1 \leq i \leq n \} \)@*)
		数据关系：(*@\( R = \{ \a{a_i，a_{i+1}} \mid a_i \text{为第} \, i \,  \text{个数据元素，} a_{i+1} \text{为第}\, i+1 \, \text{个数据元素} \} \)@*)
				  约定：队头为 a_0, 队尾为 a_n。
		基本操作：
			InitPQueue(&Q)
				操作结果：构造一个空优先级队列 Q。
			DestroyPQueue(&Q)
				初始条件：优先级队列 Q 存在。
				操作结果：销毁优先级队列 Q。
			IsEmpty(Q)
				初始条件：优先级队列 Q 存在。
				操作结果：若 Q 为空队列, 则返回 true, 否则返回 false。
			PQueueLength(Q)
				初始条件：优先级队列 Q 存在。
				操作结果：返回 Q 的元素个数。
			GetHead(Q, &e)
				初始条件：优先级队列 Q 存在, Q 非空。
				操作结果：用 e 返回 Q 中优先级最高的元素。
			EnPQueue(&Q, e)
				初始条件：优先级队列 Q 存在。
				操作结果：将元素 e 插入优先级队列 Q。
			ChangePQueue(&Q, ei, ef)
				初始条件：优先级队列 Q 存在, Q 非空, ei 是 Q 中的元素。
				操作结果：将 Q 中元素 ei 的优先级改为 ef。
			DePQueue(&Q, &e)
				初始条件：优先级队列 Q 存在, Q 非空。
				操作结果：将 Q 中优先级最高的元素出优先级队列，并用 e 返回其值。
			ClearPQueue(&Q)
				初始条件：优先级队列 Q 存在。
				操作结果：将 Q 重置为空优先级队列。
			PQueueTraverse(Q, visit())
				初始条件：优先级队列 Q 存在, visit() 是对数据元素操作的函数。
				操作结果：依次对 Q 的每个数据元素调用 visit(), 一旦 visit() 失败, 则操作失败。
	} ADT PQueue
\end{lstlisting}

优先级队列可以基于有序或无序的顺序表或链表实现。
有序的优先级队列可以在插入时按照优先级顺序插入，插入操作的时间复杂度为 \(O(n)\)；
而无序的优先级队列则需要在出队列时遍历所有元素找到优先级最高的元素，出队列操作的时间复杂度为 \(O(n)\)。各种实现方式中，入队、修改、出队操作的时间复杂度如表 \ref{Tab: Time Complexity of PQueue} 所示。

\begin{table}[!ht]
	\centering
	\caption{优先级队列的时间复杂度}
	\label{Tab: Time Complexity of PQueue}
	\begin{tabular}[b]{cccccc}
		\toprule
		\multicolumn{2}{c}{\textbf{操作}} & \textbf{有序顺序表} & \textbf{无序顺序表} & \textbf{有序链表} & \textbf{无序链表} \\
		\midrule
		入队 & \lstinline[morekeywords={[3]{EnPQueue}}]|EnPQueue(&Q, e)|
		& \(O(n)\) & \(O(1)\) & \(O(n)\) & \(O(1)\) \\
		修改 & \lstinline[morekeywords={[3]{ChangePQueue}}]|ChangePQueue(&Q, ei, ef)|
		& \(O(n)\) & \(O(1)\) & \(O(n)\) & \(O(1)\) \\
		出队 & \lstinline[morekeywords={[3]{DePQueue}}]|DePQueue(&Q, &e)|
		& \(O(n)\) & \(O(n)\) & \(O(1)\) & \(O(n)\) \\
		\bottomrule
	\end{tabular}
\end{table}

若优先级队列需要频繁进行入队操作，可以考虑使用无序顺序表或无序链表实现；若优先级队列需要频繁进行出队操作，可以考虑使用有序链表实现。

\zhu[优先级队列与栈、队列的联系]{
	优先级队列是一种特殊的队列，其出队操作是根据元素的优先级进行的。同时，优先级队列可以看作是栈和队列的推广，若设定元素在队中的停留时间为其优先级，那么栈就是时间越短优先级越高的优先级队列，队列就是时间越长优先级越高的优先级队列。
}

\subsubsection{串}

\de[串]{
	\tboba{串}是由零个或多个字符组成的有限序列，又称\tboba{字符串}。串中的字符数目称为串的\tboba{长度}；长度为零的串称为\tboba{空串}，记作 \(\varnothing\)。两个串\tboba{相等}当且仅当它们的长度相等，且对应位置的字符都相同。

	串中任意多个连续字符组成的子序列称为该串的\tboba{子串}，子串\textbf{首字符}在原串中的位置称为子串的\tboba{位置}。
}

串的抽象数据类型可以定义为：
\begin{lstlisting}[style=intro, morekeywords={ADT, }, morekeywords={[2]{String, }}, morekeywords={[3]{StrAssign, StrCopy, StrEmpty, StrLength, StrCompare, Concat, SubStr, Index, Replace, StrTraverse, visit, }}]
	ADT String {
		数据对象：(*@\( D = \{a_0，a_1，a_2，\cdots，a_n \mid a_i \in \)@*) char(*@，\(1 \leq i \leq n \} \)@*)
		数据关系：(*@\( R = \{ \a{a_i，a_{i+1}} \mid a_i \text{为第} \, i \,  \text{个字符，} a_{i+1} \text{为第}\, i+1 \, \text{个字符} \} \)@*)
		基本操作：
			StrAssign(&S, chars)
				初始条件：chars 是字符串常量。
				操作结果：生成一个其值等于 chars 的串 S。
			StrCopy(&S, T)
				初始条件：串 T 存在。
				操作结果：由串 T 复制得到串 S。
			StrEmpty(S)
				初始条件：串 S 存在。
				操作结果：若 S 为空串, 则返回 true, 否则返回 false。
			StrLength(S)
				初始条件：串 S 存在。
				操作结果：返回 S 的长度。
			StrCompare(S, T)
				初始条件：串 S 和 T 存在。
				操作结果：若 S > T, 则返回正数；若 S = T, 则返回 0；若 S < T, 则返回负数。
			Concat(&S, T1, T2)
				初始条件：串 T1 和 T2 存在。
				操作结果：用 S 返回由 T1 和 T2 连接而成的新串。
			SubStr(&S, T, pos, len)
				初始条件：串 T 存在, 1 <= pos <= StrLength(T), 0 <= len <= StrLength(T) - pos + 1。
				操作结果：用 S 返回串 T 的第 pos 个字符起长度为 len 的子串。
			Index(S, T, pos)
				初始条件：串 S 和 T 存在, 1 <= pos <= StrLength(S)。
				操作结果：若 S 中存在和 T 值相同的子串, 则返回 S 中从第 pos 个字符起第一个这样的子串的位置, 否则返回 0。
			Replace(&S, T, V)
				初始条件：串 S、T 和 V 存在, T 非空。
				操作结果：用 V 替换 S 中出现的所有与 T 相等的不重叠的子串。
			StrTraverse(S, visit())
				初始条件：串 S 存在, visit() 是对数据元素操作的函数。
				操作结果：依次对 S 的每个数据元素调用 visit(), 一旦 visit() 失败, 则操作失败。
	} ADT String
\end{lstlisting}

对串操作的最小子集包括
串赋值 \lstinline[morekeywords={[3]{StrAssign}}]|StrAssign()|、
串复制 \lstinline[morekeywords={[3]{StrCopy}}]|StrCopy()|、
串求长 \lstinline[morekeywords={[3]{StrLength}}]|StrLength()|、
串比较 \lstinline[morekeywords={[3]{StrCompare}}]|StrCompare()|、
串连接 \lstinline[morekeywords={[3]{Concat}}]|Concat()|、
求子串 \lstinline[morekeywords={[3]{SubStr}}]|SubStr()| 操作。

\paragraph{串的实现}

串的存储和一般的线性表类似，可以用顺序存储结构或链式存储结构实现。

\begin{itemize}
	\item \textbf{串的顺序存储}：串的顺序存储结构是用一组地址连续的存储单元依次存放串中的字符。根据其长度规定，又可以分为：
	\begin{itemize}
		\item \textbf{定长顺序存储}，即串的长度是固定的，不足部分用特殊字符填充；
		\item \textbf{变长顺序存储}，即串的长度是动态分配的，可以根据需要动态调整，串的结束标志是特殊字符。
	\end{itemize}
	\item \textbf{串的链式存储}：串的链式存储结构是用链表存放串中的字符，每个结点存放一定数量的字符，一个结点存储的字符个数称为\textbf{结点大小}。
\end{itemize}

\paragraph{串的模式匹配}

给定一个文本串 \(T\) 和一个模式串 \(P\)，模式匹配是指在文本串 \(T\) 中查找模式串 \(P\) 的过程。若 \(T\) 中存在一个子串与 \(P\) 完全相同，则称模式串 \(P\) 在文本串 \(T\) 中匹配成功。

\textbf{蛮力穷举}是一种简单的模式匹配算法，其基本思想是：
\begin{itemize}
	\item 从文本串 \(T\) 的第一个字符开始，依次与模式串 \(P\) 的第一个字符开始比较；
	\item 若不匹配，则文本串向后移动一位，模式串从头开始比较；
	\item 若匹配，则继续比较下一个字符，直到模式串匹配成功或文本串遍历完毕。
\end{itemize}
蛮力穷举算法的时间复杂度为 \(O(m \cdot n)\)，其中 \(m\) 为模式串 \(P\) 的长度，\(n\) 为文本串 \(T\) 的长度。C++ 中 \lstinline|std::string| 类的 \lstinline|find| 函数即是蛮力穷举算法的实现。

\di[KMP算法]{
	在模式串 \(P\) 与文本串 \(T\) 的匹配过程中, 当遇到不匹配的字符时, 根据已经匹配的信息, 尽量减少不必要的比较次数。
}{
	（1）\textbf{构造模式串的部分匹配表}：对于模式串 \(P\)，求取一个部分匹配表 \lstinline|next|，其中 \lstinline|next[i]| 表示模式串 \(P[0:i]\) 的最长相同前后缀的长度。\\
	（2）\textbf{匹配文本串}：在文本串 \(T\) 中匹配模式串 \(P\)，若遇到不匹配的字符，则根据部分匹配表 \lstinline|next| 调整模式串的位置。
}

算法的关键是构造模式串部分匹配表 \lstinline|next| 的函数 \lstinline[morekeywords={[3]{Next}}]|Next()|，其 C++ 实现如下：
\begin{lstlisting}[style=algo, morekeywords={[3]{Next}}]
	void Next(char *P, int next[]) {
		int m = strlen(P), i = 1, j = 0;
		next[0] = 0;
		while (i < m) {
			if (P[i] == P[j]) next[i++] = ++j;		// 相同字符, next[i] = j + 1
			else if (j > 0) j = next[j - 1];		// 不同字符, 回溯到前一个字符
			else next[i++] = 0;						// 不同字符且无法回溯, next[i] = 0
		}
	}
\end{lstlisting}
这样，将文本串 \(T\) 与模式串 \(P\) 进行匹配的函数 \lstinline[morekeywords={[3]{KMP}}]|KMP()| 的 C++ 实现如下：
\begin{lstlisting}[style=algo, morekeywords={[3]{KMP}}]
	int KMP(char *T, char *P) {
		int n = strlen(T), m = strlen(P), i = 0, j = 0;
		int *next = new int[m];
		Next(P, next);
		while (i < n) {
			if (T[i] == P[j]) {
				if (j == m - 1) return i - j;		// 匹配成功
				else { i++; j++; }
			} else if (j > 0) j = next[j - 1];
			else i++;
		}
		delete[] next;
		return -1;									// 匹配失败
	}
\end{lstlisting}
KMP 算法的时间复杂度为 \(O(m + n)\)，其中 \(m\) 为模式串 \(P\) 的长度，\(n\) 为文本串 \(T\) 的长度。

\subsection{树}

\subsubsection{树的基本概念}

树是一种由\textbf{一对多}分支关系定义的层级结构。

\de[树]{
	\tboba{树}是由 \(n (n \geq 0)\) 个结点组成的有限集合，满足：
	\begin{itemize}[leftmargin=1em]
		\item 若 \(n = 0\)，则称为\tboba{空树}；
		\item 对 \(n > 0\) 的非空树：
		\begin{itemize}[leftmargin=1em]
			\item 有且仅有一个特定的称为\tboba{根}（root）的结点，只有直接后继，没有直接前驱；
			\item 除根以外的其余结点划分为 \(m (m > 0)\) 个互不相交的有限集合 \(T_1, T_2, \cdots, T_m\)，每个集合本身又是一棵树，称为根的\tboba{子树}（subtree）。子树的根节点有且仅有一个直接前驱，可以有 0 个或多个直接后继。没有直接后继的结点称为\tboba{叶子}（leaf）。
		\end{itemize}
	\end{itemize}
}

\begin{definition}
	一个结点处的子树的个数称为该结点的\tboba{度}，树中结点的最大度称为树的\tboba{度}。如果树的度为 \(k\)，则称该树为 \(\mboba{k}\)~\tboba{叉树}。
\end{definition}

\begin{definition}
	对树中的结点 \(v\)，其直接后继（或者说其子树的根）称为 \(v\) 的\tboba{孩子}（child）结点，\(v\) 称为孩子结点的\tboba{双亲}（parent）结点；结点 \(v\) 的孩子结点之间互为\tboba{兄弟}（sibling）结点，\(v\) 的不同孩子结点的孩子结点之间互为\tboba{堂兄弟}（cousin）结点；从根结点到结点 \(v\) 的路径上的结点都是 \(v\) 的\tboba{祖先}（ancestor）结点，\(v\) 的所有子树中的结点都是 \(v\) 的\tboba{后裔}（descendant）结点。
\end{definition}

\begin{definition}
	树中结点的\tboba{层次}从根开始定义，根结点的层次为 1，其余结点的层次等于其双亲结点的层次加 1；树中（叶子）结点的最大层次称为树的\tboba{深度}（depth）。
\end{definition}

从离散数学的角度，树结构有如下性质：
\begin{theorem}
	树中结点的数目等于所有结点的度数和加 \(1\)。
\end{theorem}

\begin{theorem}
	度为 \(k\) 的树中第 \(i\) 层上最多有 \(k^{i-1}\) 个结点。
\end{theorem}

\begin{theorem}
	深度为 \(h\) 的 \(k\) 叉树最多有 \(\dfrac{k^h - 1}{k - 1}\) 个结点；有 \(n\) 个结点的 \(k\) 叉树的最小深度为 \(\bigl\lceil \log_k(n \cdot (k - 1) + 1) \bigr\rceil\)。
\end{theorem}

\subsubsection{二叉树}

\tboba{二叉树}是一种特殊的树，其每个结点最多有两个子树，且子树有左右之分，次序不能颠倒。

\de[二叉树]{
	\tboba{二叉树}是一个包含 \(n\) 个结点的有限集合，满足：
	\begin{itemize}[leftmargin=1em]
		\item 若 \(n = 0\)，则称为\tboba{空二叉树}；
		\item 若 \(n > 0\)，则满足：
		\begin{itemize}[leftmargin=1em]
			\item 有且仅有一个特定的称为\tboba{根}（root）的结点，只有直接后继，没有直接前驱；
			\item 除根以外的其余结点划分为两个互不相交的有限集合 \(L\) 和 \(R\)，每个集合本身又是一棵二叉树，分别称为根的\tboba{左子树}（left subtree）和\tboba{右子树}（right subtree）；\(L\) 和 \(R\) 的根节点分别称为根的\tboba{左孩子}（left child）和\tboba{右孩子}（right child）。
		\end{itemize}
	\end{itemize}
}

\de[完全二叉树、满二叉树]{
	若一棵深度为 \(h\) 的二叉树，除第 \(h\) 层外，其它各层的结点数都达到最大值，且第 \(h\) 层的结点都连续集中在最左边，则称其为\tboba{完全二叉树}；若一棵二叉树每一层的结点数都达到最大值，则称其为\tboba{满二叉树}。
}

\begin{theorem}
	具有 \(n\) 个结点的完全二叉树的深度为 \(\bigl\lceil \log_2(n+1) \bigr\rceil\)。
\end{theorem}

\begin{theorem}
	\textup{\textbf{完全二叉树的结点编号\quad}}对 \(n\) 个结点的完全二叉树自顶向下、自左向右进行 0 至 \(n-1\) 的编号，则对结点 \(i\) 有如下性质：
	\begin{itemize}
		\item 若 \(i = 0\)，则为根结点，无双亲；
		否则，其双亲结点编号为 \(\left\lfloor \dfrac{i-1}{2} \right\rfloor\)；
		\item 若 \(2i+1 > n\)，则该结点无左孩子；
		否则，其左孩子编号为 \(2i+1\)；
		\item 若 \(2i+2 > n\)，则该结点无右孩子；
		否则，其右孩子编号为 \(2i+2\)；
		\item 若 \(i\) 为非零偶数，则其左兄弟结点编号为 \(i-1\)；
		\item 若 \(i\) 为不大于 \(n-2\) 的奇数，则其右兄弟结点编号为 \(i+1\)，否则该结点无右兄弟；
		\item 结点 \(i\) 的层次为 \(\bigl\lceil \log_2(i+2) \bigr\rceil\)。
	\end{itemize}
\end{theorem}

\subsubsection{二叉树的数据结构}

二叉树的抽象数据类型可以定义为：
\begin{lstlisting}[style=intro, morekeywords={ADT, }, morekeywords={[2]{BiTree, ElemType, }}, morekeywords={[3]{InitBiTree, DestroyBiTree, CreateBiTree, ClearBiTree, BiTreeEmpty, BiTreeDepth, Root, Value, Assign, Parent, LeftChild, RightChild, LeftSibling, RightSibling, InsertChild, DeleteChild, PreOrderTraverse, InOrderTraverse, PostOrderTraverse, LevelOrderTraverse, visit, }}]
	ADT BiTree {
		数据对象：(*@\( D = \{a_0, a_1, a_2, \cdots, a_n \mid a_i \in \)@*) ElemType(*@, \(1 \leq i \leq n \} \)@*)
		数据关系：
			若 (*@\( D = \varnothing \)@*), 则 (*@\( R = \varnothing \)@*)；
			若 (*@\( D \neq \varnothing \)@*), 则 (*@\( R = H \)@*), 其中 (*@\( H \)@*) 是一个二元关系, 满足：
			+ (*@\( \exists root \in D \)@*), (*@\( \forall v \in D \)@*), (*@\( \langle v, root \rangle \notin H \)@*)；
			+ 若 (*@\( D - \{root\} \neq \varnothing \)@*), 则 (*@\( \exists D_l, D_r \subseteq D - \{root\} \)@*) 为 (*@\( D \)@*) 的划分,；
			+ 若 (*@\( D_l \neq \varnothing \)@*), 则 (*@\( \exists! x_l \in D_l \)@*), 使得 (*@\( \langle root, x_l \rangle \in H \)@*), 且 (*@\( D_l \)@*) 上的关系 (*@\( H_l \subset H \)@*)；
			  若 (*@\( D_r \neq \varnothing \)@*), 则 (*@\( \exists! x_r \in D_r \)@*), 使得 (*@\( \langle root, x_r \rangle \in H \)@*), 且 (*@\( D_r \)@*) 上的关系 (*@\( H_r \subset H \)@*)；
			  并且, 上述的 (*@\( \{\langle root, x_l \rangle, \langle root, x_r \rangle\} \)@*) 以及 (*@\( H_l \)@*) 和 (*@\( H_r \)@*) 是 (*@\( H \)@*) 的三划分。
			+ (*@\( D_l \)@*) 连带 (*@\( H_l \)@*)、(*@\( D_r \)@*) 连带 (*@\( H_r \)@*) 是符合本定义的二叉树。
		基本操作：
			InitBiTree(&T)
				操作结果：构造一个空二叉树 T。
			DestroyBiTree(&T)
				初始条件：二叉树 T 存在。
				操作结果：销毁二叉树 T。
			CreateBiTree(&T, definition)
				初始条件：二叉树 T 不存在。
				操作结果：按 definition 中给出的定义建立二叉树 T。
			ClearBiTree(&T)
				初始条件：二叉树 T 存在。
				操作结果：将二叉树 T 清空。
			isEmpty(T)
				初始条件：二叉树 T 存在。
				操作结果：若 T 为空二叉树, 则返回 true, 否则返回 false。
			GetDepth(T)
				初始条件：二叉树 T 存在。
				操作结果：返回 T 的深度。
			GetRoot(T)
				初始条件：二叉树 T 存在。
				操作结果：返回 T 的根。
			GetValue(T, cur_e)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：返回 cur_e 的值。
			Assign(&T, cur_e, value)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：将 cur_e 结点的值赋为 value。
			GetParent(T, cur_e)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：返回 cur_e 的双亲；若 cur_e 是根, 则返回空。
			LeftChild(T, cur_e)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：返回 cur_e 的左孩子；若 cur_e 无左孩子, 则返回空。
			RightChild(T, cur_e)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：返回 cur_e 的右孩子；若 cur_e 无右孩子, 则返回空。
			LeftSibling(T, cur_e)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：返回 cur_e 的左兄弟；若 cur_e 无左兄弟, 则返回空。
			RightSibling(T, cur_e)
				初始条件：二叉树 T 存在, cur_e 是 T 中的某个结点。
				操作结果：返回 cur_e 的右兄弟；若 cur_e 无右兄弟, 则返回空。
			InsertChild(&T, p, LR, c)
				初始条件：二叉树 T 存在, p 是 T 中的某个结点, LR = 0 时插入左子树, LR = 1 时插入右子树；c 为待插入的非空二叉树, 与 T 不相交且右子树为空。
				操作结果：将 p 的左子树或右子树插入 c。
			DeleteChild(&T, p, LR)
				初始条件：二叉树 T 存在, p 是 T 中的某个结点, LR = 0 时删除左子树, LR = 1 时删除右子树。
				操作结果：删除 p 的左子树或右子树。
			PreOrderTraverse(&T, visit())
				初始条件：二叉树 T 存在, visit() 是对结点操作的函数。
				操作结果：前序遍历 T, 对每个结点调用 visit()。
			InOrderTraverse(&T, visit())
				初始条件：二叉树 T 存在, visit() 是对结点操作的函数。
				操作结果：中序遍历 T, 对每个结点调用 visit()。
			PostOrderTraverse(&T, visit())
				初始条件：二叉树 T 存在, visit() 是对结点操作的函数。
				操作结果：后序遍历 T, 对每个结点调用 visit()。
			LevelOrderTraverse(&T, visit())
				初始条件：二叉树 T 存在, visit() 是对结点操作的函数。
				操作结果：层序遍历 T, 对每个结点调用 visit()。
	} ADT BiTree
\end{lstlisting}

\paragraph{二叉树的存储}

二叉树的存储结构有顺序存储结构和链式存储结构两种。

\begin{itemize}
	\item \textbf{二叉树的顺序存储}：二叉树的顺序存储结构是用一维数组存储二叉树中的结点，按照完全二叉树的结点编号规则存储。对于结点 \(i\)，其左孩子结点编号为 \(2i+1\)，右孩子结点编号为 \(2i+2\)，双亲结点编号为 \(\left\lfloor \dfrac{i-1}{2} \right\rfloor\)。
	
	对于非完全二叉树，顺序存储浪费的空间极大，如对于单分支的二叉树，顺序存储所真正使用的空间仅为所占用空间的 \(\dfrac{n}{2^{n-1}-1}\)。

	\item \textbf{二叉树的链式存储}：二叉树的链式存储结构是用链表存储二叉树中的结点，每个结点包含数据域和两个指针域，分别指向左孩子和右孩子。
	考虑到寻求双亲结点的需求，也可在结点中增加一个指向双亲结点的指针域。

	链式存储结构的二叉树的结点定义如下：
	\begin{lstlisting}[style=intro, gobble=8, morekeywords={[2]{TNode, nodeForBiTree, ElemType}}, morekeywords={[3]{InitBiTree, DestroyBiTree, CreateBiTree, ClearBiTree, BiTreeEmpty, BiTreeDepth, Root, Value, Assign, Parent, LeftChild, RightChild, LeftSibling, RightSibling, InsertChild, DeleteChild, PreOrderTraverse, InOrderTraverse, PostOrderTraverse, LevelOrderTraverse, visit, }}, xleftmargin=1em]
		typedef struct nodeForBiTree {
			ElemType data;
			struct TNode *lchild, *rchild, *parent;
		} TNode;
	\end{lstlisting}

	这样，可以用 C++ 实现二叉树的数据结构如下：
	\begin{lstlisting}[style=intro, gobble=8, morekeywords={[2]{BiTree, TNode, ElemType}}, morekeywords={[3]{InitBiTree, DestroyBiTree, CreateBiTree, ClearBiTree, BiTreeEmpty, BiTreeDepth, Root, Value, Assign, Parent, LeftChild, RightChild, LeftSibling, RightSibling, InsertChild, DeleteChild, PreOrderTraverse, InOrderTraverse, PostOrderTraverse, LevelOrderTraverse, visit, }}, xleftmargin=1em]
		class BiTree {
		private:
			TNode *root;
		public:
			BiTree() 									{ root = nullptr; }
			~BiTree() 									{ DestroyBiTree(); }
			void InitBiTree() 							{ root = nullptr; }
			void DestroyBiTree() 
				{ void deleteTNode(TNode *t) { delete t; }
				  PostOrderTraverse(deleteTNode); root = nullptr; }
			void CreateBiTree( /* 规则 */ )				{ /* 递归创建二叉树 */ }
			void ClearBiTree() 							{ DestroyBiTree(); }
			bool isEmpty() 								{ return root == nullptr; }
			int getDepth() 								{ /* 递归计算二叉树深度 */; }
			TNode* getRoot() 							{ return root; }
			ElemType getValue(TNode *cur_e) 			{ return cur_e->data; }
			void Assign(TNode *cur_e, ElemType value) 	{ cur_e->data = value; }
			TNode* Parent(TNode *cur_e) 				{ return cur_e->parent; }
			TNode* LeftChild(TNode *cur_e) 				{ return cur_e->lchild; }
			TNode* RightChild(TNode *cur_e) 			{ return cur_e->rchild; }
			TNode* LeftSibling(TNode *cur_e) 			{ return cur_e->parent->lchild; }
			TNode* RightSibling(TNode *cur_e) 			{ return cur_e->parent->rchild; }
			void InsertChild(TNode *p, int LR, BiTree c) 		{ /* 插入子树 */ }
			void DeleteChild(TNode *p, int LR) 					{ /* 删除子树 */ }
			void PreOrderTraverse(void (*visit)(TNode*)) 		{ /* 前序遍历 */ }
			void InOrderTraverse(void (*visit)(TNode*)) 		{ /* 中序遍历 */ }
			void PostOrderTraverse(void (*visit)(TNode*)) 		{ /* 后序遍历 */ }
			void LevelOrderTraverse(void (*visit)(TNode*)) 		{ /* 层序遍历 */ }
		};
	\end{lstlisting}
\end{itemize}
\paragraph{二叉树的遍历}

二叉树是一种递归结构，可以用递归思路来研究二叉树遍历方法。根据访问根节点时机，二叉树的遍历可分为\tbome{前序遍历}、\tbome{中序遍历}、\tbome{后序遍历}；还可以对二叉树自上而下逐层遍历，即\tbome{层序遍历}。

\di[二叉树的递归遍历]{
	在遍历左、右子树时，递归调用遍历函数；在访问根节点时，执行边界操作。
}{
	\hskip0.65em容易实现。
}

\begin{itemize}
	\item \textbf{前序遍历}：先访问根节点，再前序遍历左子树，最后前序遍历右子树，即
	\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode}}, morekeywords={[3]{PreOrderTraverse, visit}}, gobble=8, xleftmargin=1em]
		void PreOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
			if (t) {									// 若二叉树非空
				visit(t->data);							// 访问根节点
				PreOrderTraverse(t->lchild, visit);		// 前序遍历左子树
				PreOrderTraverse(t->rchild, visit);		// 前序遍历右子树
			}
		}
	\end{lstlisting}
	\item \textbf{中序遍历}：先中序遍历左子树，再访问根节点，最后中序遍历右子树，即
	\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode}}, morekeywords={[3]{InOrderTraverse, visit}}, gobble=8, xleftmargin=1em]
		void InOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
			if (t) {									// 若二叉树非空
				InOrderTraverse(t->lchild, visit);		// 中序遍历左子树
				visit(t->data);							// 访问根节点
				InOrderTraverse(t->rchild, visit);		// 中序遍历右子树
			}
		}
	\end{lstlisting}
	\item \textbf{后序遍历}：先后序遍历左子树，再后序遍历右子树，最后访问根节点，即
	\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode}}, morekeywords={[3]{PostOrderTraverse, visit}}, gobble=8, xleftmargin=1em]
		void PostOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
			if (t) {									// 若二叉树非空
				PostOrderTraverse(t->lchild, visit);	// 后序遍历左子树
				PostOrderTraverse(t->rchild, visit);	// 后序遍历右子树
				visit(t->data);							// 访问根节点
			}
		}
	\end{lstlisting}
\end{itemize}

递归算法简介、清晰，但是递归深度过大时会导致栈溢出，因此可以考虑用非递归算法实现二叉树的遍历，即\tbome{消除递归}。对这类较复杂的递归情况，消除递归就是用一个显式的栈来模拟递归调用的隐式的栈。

\di[二叉树的非递归遍历]{
	用一个栈来模拟递归调用的隐式栈，实现二叉树的非递归遍历。
}{
	（1）创建一个栈，用于保存结点；
	（2）按照需要的遍历顺序开始遍历，遇到要经过但没有访问的结点或没有访问某一侧孩子的结点时，将其入栈；
	（3）访问到叶子结点，出栈一个结点继续遍历。
}

\begin{itemize}
	\item \textbf{前序遍历}：用栈保存没有访问右孩子的结点，即
	\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode, stack}}, morekeywords={[3]{PreOrderTraverse, visit}}, gobble=8, xleftmargin=1em]
		void PreOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
			stack<Tnode*> s;				// 创建栈保存结点
			Tnode* p = t;					// 从根结点出发遍历
			while (p || !s.empty()) {
				if (p) {					// 若结点非空
					visit(p);				// 访问结点
					s.push(p);				// 结点入栈
					p = p->lchild;			// 移至左孩子
				} else {					// 若结点为空
					p = s.top(); s.pop();	// 出栈一个结点
					p = p->rchild;			// 移至右孩子
				}
			}
		}
	\end{lstlisting}
	\item \textbf{中序遍历}：用栈保存移入了左孩子但没有访问的结点，即
	\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode, stack}}, morekeywords={[3]{InOrderTraverse, visit}}, gobble=8, xleftmargin=1em]
		void InOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
			stack<Tnode*> s;				// 创建栈保存结点
			Tnode* p = t;					// 从根结点出发遍历
			while (p || !s.empty()) {
				if (p) {					// 若结点非空
					s.push(p);				// 结点入栈
					p = p->lchild;			// 移至左孩子
				} else {					// 若结点为空
					p = s.top(); s.pop();	// 出栈一个结点
					visit(p);				// 访问结点
					p = p->rchild;			// 移至右孩子
				}
			}
		}
	\end{lstlisting}
	\item \textbf{后序遍历}：用栈保存访问过右孩子但没有访问的结点，即
	\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode, stack}}, morekeywords={[3]{PostOrderTraverse, visit}}, gobble=8, xleftmargin=1em]
		void PostOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
			stack<Tnode*> s;				// 创建栈保存结点
			Tnode* p = t, *r = nullptr;		// 从根结点出发遍历
			while (p || !s.empty()) {
				if (p) {					// 若结点非空
					s.push(p);				// 结点入栈
					p = p->lchild;			// 移至左孩子
				} else {					// 若结点为空
					p = s.top();			// 取栈顶结点
					if (p->rchild && p->rchild != r) {	// 若右孩子存在且未访问
						p = p->rchild;		// 移至右孩子
					} else {				// 若右孩子不存在或已访问
						visit(p);			// 访问结点
						r = p;				// 记录访问过的结点
						s.pop();			// 出栈一个结点
						p = nullptr;		// 结点置空
					}
				}
			}
		}
	\end{lstlisting}
\end{itemize}

\di[二叉树的层序遍历]{
	用队列保存每一层的结点，实现二叉树的层序遍历。
}{
	（1）创建一个队列，用于保存每一层的结点；
	（2）从根结点开始，将根结点入队；
	（3）反复执行：出队一个结点，访问该结点，将其左右孩子入队；
	（4）直至队列为空。
}

\begin{lstlisting}[style=algo, morekeywords={[2]{Tnode, queue}}, morekeywords={[3]{LevelOrderTraverse, visit}}]
	void LevelOrderTraverse(Tnode* t, void (*visit)(Tnode*)) {
		queue<Tnode*> q;						// 创建队列保存结点
		Tnode* p = t;							// 从根结点出发遍历
		q.push(p);								// 根结点入队
		while (!q.empty()) {
			p = q.front(); q.pop();				// 出队一个结点
			visit(p);							// 访问结点
			if (p->lchild) q.push(p->lchild);	// 左孩子入队
			if (p->rchild) q.push(p->rchild);	// 右孩子入队
		}
	}
\end{lstlisting}

\paragraph{二叉树的建立}

二叉树的遍历是把树状的二叉树结构转换为线性的遍历序列，这个过程显然是不可逆的，即\textbf{根据一个遍历序列无法唯一建立一棵二叉树}。要根据遍历序列建立二叉树，需要更多的信息：
\begin{itemize}
	\item 同时给定\textbf{前序序列和中序序列}可唯一地建立一棵二叉树。其基本思想是，前序序列的第一个结点是根结点，根据中序序列将结点分为左右子树，于是可以回到前序序列中找到左右子树的根结点，递归建立左右子树。
	\item 同时给定\textbf{后序序列和中序序列}可唯一地建立一棵二叉树，其基本思想也类似。
	\item 同时给定\textbf{前序序列和后序序列}无法唯一地建立一棵二叉树，因为没有提供更多关于左右子树划分的信息。
\end{itemize}






\newpage
%----------------------------------------------------------
\appendix
\section{LambdaOJ平台介绍}

\subsection{判题结果}
判题有如下结果：
\begin{itemize}
	\item \code[green]{ACCEPTED}：结果完全正确。
	\item \code{WRONG_ANSWER}：程序正常执行，也没有超时和超内存，但是答案不对。
	\item \code{TIME_LIMIT_EXCEEDED}：程序超时，可能是死循环，也可能是算法不够优，或者实现不够优；还没到核对答案那一步，内存情况也不明。
	\item \code{MEMORY_LIMIT_EXCEEDED}：程序超过内存限制，可能是算法不够优，或者实现不够优；也没有到核对答案那一步。
	\item \code{OUTPUT_LIMIT_EXCEEDED}：输出数据过多，要么程序有bug，要么是恶意代码。
	\item \code{BAD_SYSCALL}：使用了非法的系统调用，要么是恶意代码，大部分情况是C++在\,\lstinline{new}\,一块内存的时候，超过了限制失败了，C++运行时环境需要一个系统调用关闭信号，然后杀死这个进程。
	\item \code{RUN_TIME_ERROR}：运行时错误，可能是由于除零、引用空指针或者数组越界等等。
\end{itemize}

\subsection{注意事项}

尽量使用\,\lstinline{stdio.h}\,而不使用\,\lstinline{iostream}，前者的输入输出效率更高，时间和空间开销更小。
%----------------------------------------------------------
\end{document}